<!DOCTYPE html>
<html lang="zh-Hans">

<head>
    <title>Keil-C51-C-to-SDCC-C Converter</title>

    <link rel="stylesheet" href="./codemirror-5.31.0/lib/codemirror.css" />
    <script src="./codemirror-5.31.0/lib/codemirror.js"></script>
    <script src="./codemirror-5.31.0/clike.js"></script>
    <link rel="stylesheet" href="./codemirror-5.31.0/theme/myTheme.css" />
    <link rel="stylesheet" href="./codemirror-5.31.0/addon/fold/foldgutter.css" />
    <script src="./codemirror-5.31.0/addon/fold/foldcode.js"></script>
    <script src="./codemirror-5.31.0/addon/fold/foldgutter.js"></script>
    <script src="./codemirror-5.31.0/addon/fold/brace-fold.js"></script>
    <script src="./codemirror-5.31.0/addon/fold/comment-fold.js"></script>
    <script src="./codemirror-5.31.0/addon/edit/matchbrackets.js"></script>

    <script src="./codemirror-5.31.0/addon/scroll/annotatescrollbar.js"></script>
    <script src="./codemirror-5.31.0/addon/search/matchesonscrollbar.js"></script>
    <script src="./codemirror-5.31.0/addon/search/match-highlighter.js"></script>
    <script src="./codemirror-5.31.0/addon/search/jump-to-line.js"></script>

    <script src="./codemirror-5.31.0/addon/dialog/dialog.js"></script>
    <link rel="stylesheet" href="./codemirror-5.31.0/addon/dialog/dialog.css" />
    <script src="./codemirror-5.31.0/addon/search/searchcursor.js"></script>
    <script src="./codemirror-5.31.0/addon/search/search.js"></script>

    <script src="./codemirror-5.31.0/jquery-3.3.1.js"></script>

    <style type="text/css">
        .container {
            display: grid;
            grid-template-rows: auto;
            grid-template-columns: 39% 22% 39%;
        }

        .CodeMirror {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 16px;
        }

        .code-header {
            background-color: rgb(149, 149, 151);
            color: white;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid #F2F2F2;
            font-size: 1.1rem;
        }

        .code-window-keilc51 {
            background: #fff;
            box-shadow: 0px 0px 10px rgb(0 0 0 / 16%);
            margin: 1rem;
            overflow: hidden;
            border-radius: 1.0rem 0.2rem 0.2rem 1.0rem;
        }

        .code-window-header {
            background: #fff;
            box-shadow: 0px 0px 10px rgb(0 0 0 / 16%);
            margin: 1rem;
            overflow: hidden;
            border-radius: 0.2rem;
        }

        .code-window-sdcc {
            background: #fff;
            box-shadow: 0px 0px 10px rgb(0 0 0 / 16%);
            margin: 1rem;
            overflow: hidden;
            border-radius: 0.2rem 1.0rem 1.0rem 0.2rem;
        }

        .convert-button {
            background-color: rgb(245, 223, 77);
            color: rgb(55, 57, 72);
            font-weight: 700;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            text-decoration: none;
            transition-duration: 0.5s;
            overflow: hidden;
        }

        .convert-button:hover {
            background-color: rgb(207, 195, 133);
            background-color: rgba(245, 223, 77, 0.5);
            color: rgb(55, 57, 72);
        }

        .convert-button:active {
            background-color: rgb(110, 143, 112);
            color: rgb(55, 57, 72);
        }

        /* 未访问的链接 */
        a:link {
            color: rgb(0, 0, 0);
        }

        /* 已访问的链接 */
        a:visited {
            color: rgb(0, 0, 0);
        }

        /* 鼠标悬停链接 */
        a:hover {
            color: rgb(76, 110, 133);
        }
    </style>
</head>


<body>
    <h1>Keil-C51-C-to-SDCC-C Converter</h1>

    &nbsp;&nbsp; by <a href="http://www.VeriMake.com/" target="_blank">VeriMake</a>

    <br />

    <div class="container">

        <div class="code-window-keilc51">
            <header class="code-header">
                Keil C51 代码 &nbsp;
                <button type="button" onclick="editor_keilc51.setValue('')">清空</button>
            </header>
            <textarea class="code-editor-keilc51" id="editor-keilc51">
            </textarea>
        </div>
        <div class="code-window-header">
            <header class="code-header">
                单片机的头文件 &nbsp;
                <select id="headerMode" onchange="editor_header_changeMode()">
                    <option value="CH549">CH549.H</option>
                    <option value="Others">Others</option>
                </select>
            </header>
            <textarea class="code-editor-header" id="editor-header">
            </textarea>
            <a class="convert-button" href="javascript:execute_convert()">
                <br />==== 转换 ===><br /><br />
            </a>
        </div>
        <div class="code-window-sdcc">
            <header class="code-header">
                转换后的 SDCC 代码 &nbsp;
                <button type="button" onclick="copyResult()">复制</button> &nbsp;
                <a href="./assets/compiler.h" download="compiler.h" target="_blank">
                    <small>下载 Compiler.h</small>
                </a>
            </header>
            <textarea class="code-editor-sdcc" id="editor-sdcc">
            </textarea>
        </div>
    </div>
    <p align="right">
        <small>
            This page is open sourced on <a href="https://github.com/CSY-tvgo/Keil-C51-C-to-SDCC-C-Converter"
                target="_blank">
                GitHub</a>.
            &nbsp;&nbsp;
        </small>
    </p>

    <script>

        const my_theme = "myTheme"

        var editor_keilc51 = CodeMirror.fromTextArea(document.getElementById("editor-keilc51"), {
            mode: "text/x-csrc",
            lineNumbers: true,
            theme: my_theme,
            foldGutter: true,
            gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
            matchBrackets: true,
            indentUnit: 4,
        })
        editor_keilc51.setSize('auto', '32rem')
        editor_keilc51.setOption("value", "// 请把 Keil C51 代码复制至此处\n// 如果你想转换头文件，也可将头文件的代码复制至此处")

        var editor_header = CodeMirror.fromTextArea(document.getElementById("editor-header"), {
            mode: "text/x-csrc",
            lineNumbers: true,
            theme: my_theme,
            foldGutter: true,
            gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
            matchBrackets: true,
            indentUnit: 4,
            scrollbarStyle: null,
        })
        editor_header.setSize('auto', '29rem')
        editor_header_changeMode()

        var editor_sdcc = CodeMirror.fromTextArea(document.getElementById("editor-sdcc"), {
            mode: "text/x-csrc",
            lineNumbers: true,
            theme: my_theme,
            foldGutter: true,
            gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
            matchBrackets: true,
            indentUnit: 4,
        })
        editor_sdcc.setSize('auto', '32rem')
        editor_sdcc.setValue("// 请先在左侧两栏中准备好代码\n// 点击转换按钮后，这里会显示转换后的代码")


        editor_keilc51.on("scroll", function () {
            var info = editor_keilc51.getScrollInfo()
            editor_sdcc.scrollTo(info["left"], info["top"])
        })
        editor_sdcc.on("scroll", function () {
            var info = editor_sdcc.getScrollInfo()
            editor_keilc51.scrollTo(info["left"], info["top"])
        })


        function editor_header_changeMode() {
            var objS = document.getElementById("headerMode")
            var selected = objS.options[objS.selectedIndex].text

            if (selected == "CH549.H") {
                ch549_h = "/*--------------------------------------------------------------------------\nCH549.H\nHeader file for CH549 microcontrollers.\n****************************************\n**  Copyright  (C)  W.ch  1999-2014   **\n**  Web:              http://wch.cn   **\n****************************************\n--------------------------------------------------------------------------*/\n\n// 3 blocks: __BASE_TYPE__, __CH549_H__, __USB_DEF__\n\n#ifndef __BASE_TYPE__\n#define __BASE_TYPE__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*----- constant and type define -----------------------------------------*/\n\n#ifndef TRUE\n#define TRUE    1\n#define FALSE   0\n#endif\n#ifndef NULL\n#define NULL    0\n#endif\n\n#ifndef BOOL\ntypedef bit                             BOOL;\n#endif\n#ifndef UINT8\ntypedef unsigned char                   UINT8;\n#endif\n#ifndef UINT16\ntypedef unsigned short                  UINT16;\n#endif\n#ifndef UINT32\ntypedef unsigned long                   UINT32;\n#endif\n#ifndef UINT8D\ntypedef unsigned char  data             UINT8D;\n#endif\n#ifndef UINT16D\ntypedef unsigned short data             UINT16D;\n#endif\n#ifndef UINT32D\ntypedef unsigned long  data             UINT32D;\n#endif\n#ifndef UINT8I\ntypedef unsigned char  idata            UINT8I;\n#endif\n#ifndef UINT16I\ntypedef unsigned short idata            UINT16I;\n#endif\n#ifndef UINT32I\ntypedef unsigned long  idata            UINT32I;\n#endif\n#ifndef UINT8X\ntypedef unsigned char  xdata            UINT8X;\n#endif\n#ifndef UINT16X\ntypedef unsigned short xdata            UINT16X;\n#endif\n#ifndef UINT32X\ntypedef unsigned long  xdata            UINT32X;\n#endif\n#ifndef UINT8V\ntypedef unsigned char volatile          UINT8V;\n#endif\n#ifndef UINT8DV\ntypedef unsigned char volatile data     UINT8DV;\n#endif\n#ifndef UINT8XV\ntypedef unsigned char volatile xdata    UINT8XV;\n#endif\n#ifndef UINT8PV\ntypedef unsigned char volatile pdata    UINT8PV;\n#endif\n#ifndef UINT8C\ntypedef const unsigned char code        UINT8C;\n#endif\n#ifndef PUINT8\ntypedef unsigned char                 *PUINT8;\n#endif\n#ifndef PUINT16\ntypedef unsigned short                *PUINT16;\n#endif\n#ifndef PUINT32\ntypedef unsigned long                 *PUINT32;\n#endif\n#ifndef PUINT8I\ntypedef unsigned char  idata          *PUINT8I;\n#endif\n#ifndef PUINT16I\ntypedef unsigned short idata          *PUINT16I;\n#endif\n#ifndef PUINT32I\ntypedef unsigned long  idata          *PUINT32I;\n#endif\n#ifndef PUINT8X\ntypedef unsigned char  xdata          *PUINT8X;\n#endif\n#ifndef PUINT16X\ntypedef unsigned short xdata          *PUINT16X;\n#endif\n#ifndef PUINT32X\ntypedef unsigned long  xdata          *PUINT32X;\n#endif\n#ifndef PUINT8V\ntypedef unsigned char volatile        *PUINT8V;\n#endif\n#ifndef PUINT8DV\ntypedef unsigned char volatile data   *PUINT8DV;\n#endif\n#ifndef PUINT8XV\ntypedef unsigned char volatile xdata  *PUINT8XV;\n#endif\n#ifndef PUINT8PV\ntypedef unsigned char volatile pdata  *PUINT8PV;\n#endif\n#ifndef PUINT8C\ntypedef const unsigned char code      *PUINT8C;\n#endif\n\n#ifndef STRUCT_OFFSET\n#define STRUCT_OFFSET( s, m )       ( (UINT8)( & (((s) *)0) -> (m) ) )  /* get the offset address for a member of a structure */\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // __BASE_TYPE__\n\n#ifndef __CH549_H__\n#define __CH549_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*----- SFR --------------------------------------------------------------*/\n/*  sbit are bit addressable, others are byte addressable */\n\n/*  System Registers  */\nsfr PSW             = 0xD0;         // program status word\n sbit CY            = PSW^7;        // carry flag\n sbit AC            = PSW^6;        // auxiliary carry flag\n sbit F0            = PSW^5;        // bit addressable general purpose flag 0\n sbit RS1           = PSW^4;        // register R0-R7 bank selection high bit\n sbit RS0           = PSW^3;        // register R0-R7 bank selection low bit\n#define MASK_PSW_RS       0x18      // bit mask of register R0-R7 bank selection\n// RS1 & RS0: register R0-R7 bank selection\n//    00 - bank 0, R0-R7 @ address 0x00-0x07\n//    01 - bank 1, R0-R7 @ address 0x08-0x0F\n//    10 - bank 2, R0-R7 @ address 0x10-0x17\n//    11 - bank 3, R0-R7 @ address 0x18-0x1F\n sbit OV            = PSW^2;        // overflow flag\n sbit F1            = PSW^1;        // bit addressable general purpose flag 1\n sbit P             = PSW^0;        // ReadOnly: parity flag\nsfr ACC             = 0xE0;         // accumulator\nsfr B               = 0xF0;         // general purpose register B\nsfr A_INV           = 0xFD;         // ReadOnly: bit inversion of ACC (bit0<->bit7,bit1<->bit6,bit2<->bit5,bit3<->bit4, [7..0]->[0..7])\nsfr SP              = 0x81;         // stack pointer\n//sfr16 DPTR          = 0x82;         // DPTR pointer, little-endian\nsfr DPL             = 0x82;         // data pointer low\nsfr DPH             = 0x83;         // data pointer high\nsfr SAFE_MOD        = 0xA1;         // WriteOnly: writing safe mode\n//sfr CHIP_ID         = 0xA1;         // ReadOnly: reading chip ID\n#define CHIP_ID           SAFE_MOD\nsfr GLOBAL_CFG      = 0xB1;         // global config, Write@SafeMode\n#define bBOOT_LOAD        0x20      // ReadOnly: boot loader status for discriminating BootLoader or Application: set 1 by power on reset, clear 0 by software reset\n#define bSW_RESET         0x10      // software reset bit, auto clear by hardware\n#define bCODE_WE          0x08      // enable flash-ROM (include code & Data-Flash) being program or erasing: 0=writing protect, 1=enable program and erase\n#define bDATA_WE          0x04      // enable Data-Flash (flash-ROM data area) being program or erasing: 0=writing protect, 1=enable program and erase\n#define bWDOG_EN          0x01      // enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow\n\n/* Clock and Sleep and Power Registers */\nsfr PCON            = 0x87;         // power control and reset flag\n#define SMOD              0x80      // baud rate selection for UART0 mode 1/2/3: 0=slow(Fsys/128 @mode2, TF1/32 @mode1/3, no effect for TF2),\n                                    //   1=fast(Fsys/32 @mode2, TF1/16 @mode1/3, no effect for TF2)\n#define bRST_FLAG1        0x20      // ReadOnly: recent reset flag high bit\n#define bRST_FLAG0        0x10      // ReadOnly: recent reset flag low bit\n#define MASK_RST_FLAG     0x30      // ReadOnly: bit mask of recent reset flag\n#define RST_FLAG_SW       0x00\n#define RST_FLAG_POR      0x10\n#define RST_FLAG_WDOG     0x20\n#define RST_FLAG_PIN      0x30\n// bPC_RST_FLAG1 & bPC_RST_FLAG0: recent reset flag\n//    00 - software reset, by bSW_RESET=1 @(bBOOT_LOAD=0 or bWDOG_EN=1)\n//    01 - power on reset\n//    10 - watch-dog timer overflow reset\n//    11 - external input manual reset by RST pin\n#define GF1               0x08      // general purpose flag bit 1\n#define GF0               0x04      // general purpose flag bit 0\n#define PD                0x02      // power-down enable bit, auto clear by wake-up hardware\nsfr POWER_CFG       = 0xBA;         // power config, Write@SafeMode\n#define bPWR_DN_MODE      0x80      // power down mode: 0=deep sleep and slow waking, 1=standby and fast waking\n#define bUSB_PU_RES       0x40      // USB pullup resistance mode: 0=1.5K for 3.3V, 1=7K for 5V\n#define bLV_RST_OFF       0x20      // disable low voltage reset: 0=enable LVR, 1=disable LVR\n#define bLDO_3V3_OFF      0x10      // disable 5V->3.3V LDO: 0=enable LDO for USB I/O, 1=disable 3.3V LDO, short V33 and VDD power\n#define bLDO_CORE_VOL     0x08      // core voltage mode: 0=normal, 1=raised for performance\n#define MASK_ULLDO_VOL    0x07      // bit mask of ULLDO voltage selection\nsfr CLOCK_CFG       = 0xB9;         // system clock config: lower 3 bits for system clock Fsys, Write@SafeMode\n#define bOSC_EN_INT       0x80      // internal oscillator enable and original clock selection: 1=enable & select internal clock, 0=disable & select external clock\n#define bOSC_EN_XT        0x40      // external oscillator enable, need quartz crystal or ceramic resonator between XI and XO pins\n#define bWDOG_IF_TO       0x20      // ReadOnly: watch-dog timer overflow interrupt flag, cleared by reload watch-dog count or auto cleared when MCU enter interrupt routine\n#define MASK_SYS_CK_SEL   0x07      // bit mask of system clock Fsys selection\n/*\n   Fxt  = 24MHz (12MHz~30MHz for non-USB application), from external oscillator @XI&XO\n   Fosc = bOSC_EN_INT ? 24MHz : Fxt\n   Fpll = Fosc * 4 => 96MHz (48MHz~120MHz for non-USB application)\n   Fusb4x = Fpll / 2 => 48MHz (Fixed)\n              MASK_SYS_CK_SEL[2] [1] [0]\n   Fsys = Fpll/2   =  48MHz:  1   1   1\n   Fsys = Fpll/3   =  32MHz:  1   1   0\n   Fsys = Fpll/4   =  24MHz:  1   0   1\n   Fsys = Fpll/6   =  16MHz:  1   0   0\n   Fsys = Fpll/8   =  12MHz:  0   1   1\n   Fsys = Fpll/32  =   3MHz:  0   1   0\n   Fsys = Fpll/128 = 750KHz:  0   0   1\n   Fsys = Fpll/512 =187.5KHz: 0   0   0\n*/\nsfr WAKE_CTRL       = 0xA9;         // wake-up control, Write@SafeMode\n#define bWAK_BY_USB       0x80      // enable wake-up by USB event\n#define bWAK_RXD1_LO      0x40      // enable wake-up by RXD1 low level\n#define bWAK_P1_5_LO      0x20      // enable wake-up by pin P1.5 low level\n#define bWAK_P1_4_LO      0x10      // enable wake-up by pin P1.4 low level\n#define bWAK_P0_3_LO      0x08      // enable wake-up by pin P0.3 low level\n#define bWAK_P57H_INT3L   0x04      // enable wake-up by pin P5.7 high level or INT3 low level\n#define bWAK_INT0E_P33L   0x02      // enable wake-up by pin INT0 edge or pin P3.3 (INT1) low level\n#define bWAK_RXD0_LO      0x01      // enable wake-up by RXD0 low level\nsfr RESET_KEEP      = 0xFE;         // value keeper during reset\nsfr WDOG_COUNT      = 0xFF;         // watch-dog count, count by clock frequency Fsys/131072\n\n/*  Interrupt Registers  */\nsfr IE              = 0xA8;         // interrupt enable\n sbit EA            = IE^7;         // enable global interrupts: 0=disable, 1=enable if E_DIS=0\n sbit E_DIS         = IE^6;         // disable global interrupts, intend to inhibit interrupt during some flash-ROM operation: 0=enable if EA=1, 1=disable\n sbit ET2           = IE^5;         // enable timer2 interrupt\n sbit ES            = IE^4;         // enable UART0 interrupt\n sbit ET1           = IE^3;         // enable timer1 interrupt\n sbit EX1           = IE^2;         // enable external interrupt INT1\n sbit ET0           = IE^1;         // enable timer0 interrupt\n sbit EX0           = IE^0;         // enable external interrupt INT0\nsfr IP              = 0xB8;         // interrupt priority and current priority\n sbit PH_FLAG       = IP^7;         // ReadOnly: high level priority action flag\n sbit PL_FLAG       = IP^6;         // ReadOnly: low level priority action flag\n// PH_FLAG & PL_FLAG: current interrupt priority\n//    00 - no interrupt now\n//    01 - low level priority interrupt action now\n//    10 - high level priority interrupt action now\n//    11 - unknown error\n sbit PT2           = IP^5;         // timer2 interrupt priority level\n sbit PS            = IP^4;         // UART0 interrupt priority level\n sbit PT1           = IP^3;         // timer1 interrupt priority level\n sbit PX1           = IP^2;         // external interrupt INT1 priority level\n sbit PT0           = IP^1;         // timer0 interrupt priority level\n sbit PX0           = IP^0;         // external interrupt INT0 priority level\nsfr IE_EX           = 0xE8;         // extend interrupt enable\n sbit IE_WDOG       = IE_EX^7;      // enable watch-dog timer interrupt\n sbit IE_GPIO       = IE_EX^6;      // enable GPIO input interrupt\n sbit IE_PWMX       = IE_EX^5;      // enable PWMX interrupt\n sbit IE_UART3      = IE_EX^5;      // enable UART3 interrupt\n sbit IE_UART1      = IE_EX^4;      // enable UART1 interrupt\n sbit IE_ADC        = IE_EX^3;      // enable ADC interrupt\n sbit IE_UART2      = IE_EX^3;      // enable UART2 interrupt\n sbit IE_USB        = IE_EX^2;      // enable USB interrupt\n sbit IE_INT3       = IE_EX^1;      // enable external interrupt INT3\n sbit IE_SPI0       = IE_EX^0;      // enable SPI0 interrupt\nsfr IP_EX           = 0xE9;         // extend interrupt priority\n#define bIP_LEVEL         0x80      // ReadOnly: current interrupt nested level: 0=no interrupt or two levels, 1=one level\n#define bIP_GPIO          0x40      // GPIO input interrupt priority level\n#define bIP_PWMX          0x20      // PWMX interrupt priority level\n#define bIP_UART3         0x20      // UART3 interrupt priority level\n#define bIP_UART1         0x10      // UART1 interrupt priority level\n#define bIP_ADC           0x08      // ADC interrupt priority level\n#define bIP_UART2         0x08      // UART2 interrupt priority level\n#define bIP_USB           0x04      // USB interrupt priority level\n#define bIP_INT3          0x02      // external interrupt INT3 priority level\n#define bIP_SPI0          0x01      // SPI0 interrupt priority level\nsfr INTX            = 0xB3;         // external interrupt INTx control and interrupt flag\n#define bIX3              0x20      // INT3 interrupt polarity: 0=low level or falling edge action, 1=high level or rising edge action\n#define bIE3              0x08      // INT3 interrupt flag, auto cleared when MCU enter interrupt routine\n#define bIT3              0x04      // INT3 interrupt type: 0=low/high level action, 1=falling/rising edge action\nsfr GPIO_IE         = 0xB2;         // GPIO interrupt enable\n#define bIE_IO_EDGE       0x80      // enable GPIO edge interrupt: 0=low/high level, 1=falling/rising edge\n#define bIE_RXD1_LO       0x40      // enable interrupt by RXD1 low level / falling edge\n#define bIE_P1_5_LO       0x20      // enable interrupt by pin P1.5 low level / falling edge\n#define bIE_P1_4_LO       0x10      // enable interrupt by pin P1.4 low level / falling edge\n#define bIE_P0_3_LO       0x08      // enable interrupt by pin P0.3 low level / falling edge\n#define bIE_P5_7_HI       0x04      // enable interrupt by pin P5.7 (RST) high level / rising edge\n#define bIE_P4_6_LO       0x02      // enable interrupt by pin P4.6 low level / falling edge\n#define bIE_RXD0_LO       0x01      // enable interrupt by RXD0 low level / falling edge\n\n/*  FlashROM and Data-Flash Registers  */\n#define ROM_PAGE_SIZE     0x40      // FlashROM page size ( number of bytes )\nsfr16 ROM_ADDR      = 0x84;         // address for flash-ROM, little-endian\nsfr ROM_ADDR_L      = 0x84;         // address low byte for flash-ROM\nsfr ROM_ADDR_H      = 0x85;         // address high byte for flash-ROM\n//sfr16 ROM_DATA_LO   = 0x84;         // ReadOnly: low word data (16 bits) for flash-ROM reading, little-endian\n#define ROM_DATA_LO       ROM_ADDR\n//sfr ROM_DATA_LL     = 0x84;         // ReadOnly: data low byte of low word for flash-ROM reading\n#define ROM_DATA_LL       ROM_ADDR_L\n//sfr ROM_DATA_LH     = 0x85;         // ReadOnly: data high byte of low word for flash-ROM reading\n#define ROM_DATA_LH       ROM_ADDR_H\nsfr16 ROM_DATA_HI   = 0x8E;         // ReadOnly: high word data (16 bits) for flash-ROM reading, little-endian\nsfr ROM_DATA_HL     = 0x8E;         // ReadOnly: data low byte of high word for flash-ROM reading\nsfr ROM_DATA_HH     = 0x8F;         // ReadOnly: data high byte of high word for flash-ROM reading\n//sfr ROM_DAT_BUF     = 0x8E;         // data byte buffer for flash-ROM program and erasing\n#define ROM_DAT_BUF       ROM_DATA_HL\n//sfr ROM_BUF_MOD     = 0x8F;         // data buffer mode and end address for flash-ROM program and erasing\n#define ROM_BUF_MOD       ROM_DATA_HH\n#define bROM_BUF_BYTE     0x80      // flash-ROM data buffer mode: 0=data block (1~64bytes) to program from xRAM pointed by DPTR, 1=only one byte for program or erasing from SFR ROM_DAT_BUF\n#define MASK_ROM_ADDR     0x3F      // bit mask for end address for flash-ROM block program if bROM_BUF_BYTE=0\nsfr ROM_CTRL        = 0x86;         // WriteOnly: flash-ROM control\n#define ROM_CMD_PROG      0x9A      // WriteOnly: flash-ROM or Data-Flash byte/page program operation command, for changing some ROM bit of a byte from 0 to 1\n#define ROM_CMD_ERASE     0xA6      // WriteOnly: flash-ROM or Data-Flash page erase operation command, for changing all ROM bit of 64-Bytes from 1 to 0\n#define ROM_CMD_RD_OTP    0x8D      // WriteOnly: OTP area dword read operation command\n#define ROM_CMD_PG_OTP    0x99      // WriteOnly: OTP area byte/page program operation command\n//sfr ROM_STATUS      = 0x86;         // ReadOnly: flash-ROM status\n#define ROM_STATUS        ROM_CTRL\n#define bROM_ADDR_OK      0x40      // ReadOnly: flash-ROM operation address valid flag, can be reviewed before or after operation: 0=invalid parameter, 1=address valid\n#define bROM_CMD_ERR      0x02      // ReadOnly: flash-ROM operation command error flag: 0=command accepted, 1=unknown command or operation time out\n\n/*  Port Registers  */\nsfr P0              = 0x80;         // port 0 input & output\n sbit P0_7          = P0^7;\n sbit P0_6          = P0^6;\n sbit P0_5          = P0^5;\n sbit P0_4          = P0^4;\n sbit P0_3          = P0^3;\n sbit P0_2          = P0^2;\n sbit P0_1          = P0^1;\n sbit P0_0          = P0^0;\n sbit TXD3          = P0^7;         // TXD output for UART3\n sbit AIN15         = P0^7;         // AIN15 for ADC\n sbit RXD3          = P0^6;         // RXD input for UART3\n sbit AIN14         = P0^6;         // AIN14 for ADC\n sbit TXD2          = P0^5;         // TXD output for UART2\n sbit AIN13         = P0^5;         // AIN13 for ADC\n sbit RXD2          = P0^4;         // RXD input for UART2\n sbit AIN12         = P0^4;         // AIN12 for ADC\n sbit TXD_          = P0^3;         // alternate pin for TXD of UART0\n sbit AIN11         = P0^3;         // AIN11 for ADC\n sbit RXD_          = P0^2;         // alternate pin for RXD of UART0\n sbit AIN10         = P0^2;         // AIN10 for ADC\n sbit AIN9          = P0^1;         // AIN9 for ADC\n sbit AIN8          = P0^0;         // AIN8 for ADC\nsfr P0_MOD_OC       = 0xC4;         // port 0 output mode: 0=push-pull, 1=open-drain\nsfr P0_DIR_PU       = 0xC5;         // port 0 direction for push-pull or pullup enable for open-drain\n#define bTXD3             0x80      // TXD output for UART3\n#define bAIN15            0x80      // AIN15 for ADC\n#define bRXD3             0x40      // RXD input for UART3\n#define bAIN14            0x40      // AIN14 for ADC\n#define bTXD2             0x20      // TXD output for UART2\n#define bAIN13            0x20      // AIN13 for ADC\n#define bRXD2             0x10      // RXD input for UART2\n#define bAIN12            0x10      // AIN12 for ADC\n#define bTXD_             0x08      // alternate pin for TXD of UART0\n#define bAIN11            0x08      // AIN11 for ADC\n#define bRXD_             0x04      // alternate pin for RXD of UART0\n#define bAIN10            0x04      // AIN10 for ADC\n#define bAIN9             0x02      // AIN9 for ADC\n#define bAIN8             0x01      // AIN8 for ADC\nsfr P1              = 0x90;         // port 1 input & output\n sbit P1_7          = P1^7;\n sbit P1_6          = P1^6;\n sbit P1_5          = P1^5;\n sbit P1_4          = P1^4;\n sbit P1_3          = P1^3;\n sbit P1_2          = P1^2;\n sbit P1_1          = P1^1;\n sbit P1_0          = P1^0;\n sbit SCK           = P1^7;         // serial clock for SPI0\n sbit TXD1_         = P1^7;         // alternate pin for TXD1\n sbit AIN7          = P1^7;         // AIN7 for ADC\n sbit MISO          = P1^6;         // master serial data input or slave serial data output for SPI0\n sbit RXD1_         = P1^6;         // alternate pin for RXD1\n sbit VBUS          = P1^6;         // VBUS for USB type-C\n sbit AIN6          = P1^6;         // AIN6 for ADC\n sbit MOSI          = P1^5;         // master serial data output or slave serial data input for SPI0\n sbit PWM0_         = P1^5;         // alternate pin for PWM0\n sbit UCC2          = P1^5;         // UCC2 for USB type-C\n sbit AIN5          = P1^5;         // AIN5 for ADC\n sbit SCS           = P1^4;         // slave chip-selection input for SPI0\n sbit UCC1          = P1^4;         // UCC1 for USB type-C\n sbit AIN4          = P1^4;         // AIN4 for ADC\n sbit AIN3          = P1^3;         // AIN3 for ADC\n sbit AIN2          = P1^2;         // AIN2 for ADC\n sbit T2EX          = P1^1;         // external trigger input for timer2 reload & capture\n sbit CAP2          = P1^1;         // capture2 input for timer2\n sbit AIN1          = P1^1;         // AIN1 for ADC\n sbit T2            = P1^0;         // external count input\n sbit CAP1          = P1^0;         // capture1 input for timer2\n sbit AIN0          = P1^0;         // AIN0 for ADC\nsfr P1_MOD_OC       = 0x92;         // port 1 output mode: 0=push-pull, 1=open-drain\nsfr P1_DIR_PU       = 0x93;         // port 1 direction for push-pull or pullup enable for open-drain\n// Pn_MOD_OC & Pn_DIR_PU: pin input & output configuration for Pn (n=1/3)\n//   0 0:  float input only, without pullup resistance\n//   0 1:  push-pull output, strong driving high level and low level\n//   1 0:  open-drain output and input without pullup resistance\n//   1 1:  quasi-bidirectional (standard 8051 mode), open-drain output and input with pullup resistance, just driving high level strongly for 2 clocks if turning output level from low to high\n#define bSCK              0x80      // serial clock for SPI0\n#define bTXD1_            0x80      // alternate pin for TXD1\n#define bAIN7             0x80      // AIN7 for ADC\n#define bMISO             0x40      // master serial data input or slave serial data output for SPI0\n#define bRXD1_            0x40      // alternate pin for RXD1\n#define bVBUS             0x40      // VBUS for USB type-C\n#define bAIN6             0x40      // AIN6 for ADC\n#define bMOSI             0x20      // master serial data output or slave serial data input for SPI0\n#define bPWM0_            0x20      // alternate pin for PWM0\n#define bUCC2             0x20      // UCC2 for USB type-C\n#define bAIN5             0x20      // AIN5 for ADC\n#define bSCS              0x10      // slave chip-selection input for SPI0\n#define bUCC1             0x10      // UCC1 for USB type-C\n#define bAIN4             0x10      // AIN4 for ADC\n#define bAIN3             0x08      // AIN3 for ADC\n#define bAIN2             0x04      // AIN2 for ADC\n#define bT2EX             0x02      // external trigger input for timer2 reload & capture\n#define bCAP2             bT2EX     // capture2 input for timer2\n#define bAIN1             0x02      // AIN1 for ADC\n#define bT2               0x01      // external count input or clock output for timer2\n#define bCAP1             bT2       // capture1 input for timer2\n#define bAIN0             0x01      // AIN0 for ADC\nsfr P2              = 0xA0;         // port 2 input & output\n sbit P2_7          = P2^7;\n sbit P2_6          = P2^6;\n sbit P2_5          = P2^5;\n sbit P2_4          = P2^4;\n sbit P2_3          = P2^3;\n sbit P2_2          = P2^2;\n sbit P2_1          = P2^1;\n sbit P2_0          = P2^0;\n sbit PWM7          = P2^7;         // PWM output for PWM7\n sbit TXD1          = P2^7;         // TXD output for UART1\n sbit PWM6          = P2^6;         // PWM output for PWM6\n sbit RXD1          = P2^6;         // RXD input for UART1\n sbit PWM0          = P2^5;         // PWM output for PWM0\n sbit T2EX_         = P2^5;         // alternate pin for T2EX\n sbit CAP2_         = P2^5;         // alternate pin for CAP2\n sbit PWM1          = P2^4;         // PWM output for PWM1\n sbit T2_           = P2^4;         // alternate pin for T2\n sbit CAP1_         = P2^4;         // alternate pin for CAP1\n sbit PWM2          = P2^3;         // PWM output for PWM2\n sbit PWM3          = P2^2;         // PWM output for PWM3\n sbit INT0_         = P2^2;         // alternate pin for INT0\n sbit PWM4          = P2^1;         // PWM output for PWM4\n sbit PWM5          = P2^0;         // PWM output for PWM5\nsfr P2_MOD_OC       = 0x94;         // port 2 output mode: 0=push-pull, 1=open-drain\nsfr P2_DIR_PU       = 0x95;         // port 2 direction for push-pull or pullup enable for open-drain\n#define bPWM7             0x80      // PWM output for PWM7\n#define bTXD1             0x80      // TXD output for UART1\n#define bPWM6             0x40      // PWM output for PWM6\n#define bRXD1             0x40      // RXD input for UART1\n#define bT2EX_            0x20      // alternate pin for T2EX\n#define bCAP2_            0x20      // alternate pin for CAP2\n#define bPWM0             0x20      // PWM output for PWM0\n#define bPWM1             0x10      // PWM output for PWM1\n#define bT2_              0x10      // alternate pin for T2\n#define bCAP1_            0x10      // alternate pin for CAP1\n#define bPWM2             0x08      // PWM output for PWM2\n#define bPWM3             0x04      // PWM output for PWM3\n#define bINT0_            0x04      // alternate pin for INT0\n#define bPWM4             0x02      // PWM output for PWM4\n#define bPWM5             0x01      // PWM output for PWM5\nsfr P3              = 0xB0;         // port 3 input & output\n sbit P3_7          = P3^7;\n sbit P3_6          = P3^6;\n sbit P3_5          = P3^5;\n sbit P3_4          = P3^4;\n sbit P3_3          = P3^3;\n sbit P3_2          = P3^2;\n sbit P3_1          = P3^1;\n sbit P3_0          = P3^0;\n sbit INT3          = P3^7;         // external interrupt 3 input\n sbit CAP0          = P3^6;         // capture0 input for timer2\n sbit T1            = P3^5;         // external count input for timer1\n sbit T0            = P3^4;         // external count input for timer0\n sbit INT1          = P3^3;         // external interrupt 1 input\n sbit INT0          = P3^2;         // external interrupt 0 input\n sbit TXD           = P3^1;         // TXD output for UART0\n sbit RXD           = P3^0;         // RXD input for UART0\nsfr P3_MOD_OC       = 0x96;         // port 3 output mode: 0=push-pull, 1=open-drain\nsfr P3_DIR_PU       = 0x97;         // port 3 direction for push-pull or pullup enable for open-drain\n#define bINT3             0x80      // external interrupt 3 input\n#define bCAP0             0x40      // capture0 input for timer2\n#define bT1               0x20      // external count input for timer1\n#define bT0               0x10      // external count input for timer0\n#define bINT1             0x08      // external interrupt 1 input\n#define bINT0             0x04      // external interrupt 0 input\n#define bTXD              0x02      // TXD output for UART0\n#define bRXD              0x01      // RXD input for UART0\nsfr P4              = 0xC0;         // port 4 input & output\n sbit P4_6          = P4^6;\n sbit P4_5          = P4^5;\n sbit P4_4          = P4^4;\n sbit P4_3          = P4^3;\n sbit P4_2          = P4^2;\n sbit P4_1          = P4^1;\n sbit P4_0          = P4^0;\n sbit XO            = P4^7;         // XO pin for external crystal oscillator\n sbit XI            = P4^6;         // XI pin for external crystal oscillator\nsfr P4_MOD_OC       = 0xC2;         // port 4 output mode: 0=push-pull, 1=open-drain\nsfr P4_DIR_PU       = 0xC3;         // port 4 direction for push-pull or pullup enable for open-drain\n#define bXO               0x80      // XO pin for external crystal oscillator\n#define bXI               0x40      // XI pin for external crystal oscillator\nsfr P5              = 0xAB;         // port 5 input & output\n#define bRST              0x80      // ReadOnly: pin RST input\n#define bHVOD             0x20      // HVOD pin for high voltage open drain output\n#define bALE              0x10      // ALE pin for GPO\n#define bCKO              bALE      // ALE clock output\n#define bUDP              0x02      // ReadOnly: pin UDP input\n#define bDP               0x02      // ReadOnly: pin UDP input\n#define bUDM              0x01      // ReadOnly: pin UDM input\n#define bDM               0x01      // ReadOnly: pin UDM input\nsfr PIN_FUNC        = 0xAA;         // pin function selection\n#define bPWM0_PIN_X       0x80      // PWM0 alternate pin enable: 0=PWM0 on P2.5, 1=PWM0 on P1.5\n#define bIO_INT_ACT       0x40      // ReadOnly: GPIO interrupt request action status\n#define bUART1_PIN_X      0x20      // UART1 alternate pin enable: 0=RXD1/TXD1 on P2.6/P2.7, 1=RXD1/TXD1 on P1.6/P1.7\n#define bUART0_PIN_X      0x10      // UART0 alternate pin enable: 0=RXD0/TXD0 on P3.0/P3.1, 1=RXD0/TXD0 on P0.2/P0.3\n#define bINT0_PIN_X       0x04      // INT0 alternate pin enable: 0=INT0 on P3.2, 1=INT0 on P2.2\n#define bT2EX_PIN_X       0x02      // T2EX/CAP2 alternate pin enable: 0=T2EX/CAP2 on P1.1, 1=T2EX/CAP2 on P2.5\n#define bT2_PIN_X         0x01      // T2/CAP1 alternate pin enable: 0=T2/CAP1 on P1.0, 1=T2/CAP1 on P2.4\nsfr XBUS_AUX        = 0xA2;         // xBUS auxiliary setting\n#define bUART0_TX         0x80      // ReadOnly: indicate UART0 transmittal status\n#define bUART0_RX         0x40      // ReadOnly: indicate UART0 receiving status\n#define bSAFE_MOD_ACT     0x20      // ReadOnly: safe mode action status\n#define bALE_CLK_EN       0x10      // enable P5.4/ALE output clock\n#define bALE_CLK_SEL      0x08      // ALE clock frequency select if bALE_CLK_EN=1: 0-1/12 Fsys, 1-1/4 Fsys\n#define GF2               0x08      // general purpose flag bit 2 if bALE_CLK_EN=0\n#define bDPTR_AUTO_INC    0x04      // enable DPTR auto increase if finished MOVX_@DPTR instruction\n#define DPS               0x01      // dual DPTR selection: 0=DPTR0 selected, 1=DPTR1 selected\n\n/*  Timer0/1 Registers  */\nsfr TCON            = 0x88;         // timer 0/1 control and external interrupt control\n sbit TF1           = TCON^7;       // timer1 overflow & interrupt flag, auto cleared when MCU enter interrupt routine\n sbit TR1           = TCON^6;       // timer1 run enable\n sbit TF0           = TCON^5;       // timer0 overflow & interrupt flag, auto cleared when MCU enter interrupt routine\n sbit TR0           = TCON^4;       // timer0 run enable\n sbit IE1           = TCON^3;       // INT1 interrupt flag, auto cleared when MCU enter interrupt routine\n sbit IT1           = TCON^2;       // INT1 interrupt type: 0=low level action, 1=falling edge action\n sbit IE0           = TCON^1;       // INT0 interrupt flag, auto cleared when MCU enter interrupt routine\n sbit IT0           = TCON^0;       // INT0 interrupt type: 0=low level action, 1=falling edge action\nsfr TMOD            = 0x89;         // timer 0/1 mode\n#define bT1_GATE          0x80      // gate control of timer1: 0=timer1 run enable while TR1=1, 1=timer1 run enable while P3.3 (INT1) pin is high and TR1=1\n#define bT1_CT            0x40      // counter or timer mode selection for timer1: 0=timer, use internal clock, 1=counter, use P3.5 (T1) pin falling edge as clock\n#define bT1_M1            0x20      // timer1 mode high bit\n#define bT1_M0            0x10      // timer1 mode low bit\n#define MASK_T1_MOD       0x30      // bit mask of timer1 mode\n// bT1_M1 & bT1_M0: timer1 mode\n//   00: mode 0, 13-bit timer or counter by cascaded TH1 and lower 5 bits of TL1, the upper 3 bits of TL1 are ignored\n//   01: mode 1, 16-bit timer or counter by cascaded TH1 and TL1\n//   10: mode 2, TL1 operates as 8-bit timer or counter, and TH1 provide initial value for TL1 auto-reload\n//   11: mode 3, stop timer1\n#define bT0_GATE          0x08      // gate control of timer0: 0=timer0 run enable while TR0=1, 1=timer0 run enable while INT0 pin is high and TR0=1\n#define bT0_CT            0x04      // counter or timer mode selection for timer0: 0=timer, use internal clock, 1=counter, use P3.4 (T0) pin falling edge as clock\n#define bT0_M1            0x02      // timer0 mode high bit\n#define bT0_M0            0x01      // timer0 mode low bit\n#define MASK_T0_MOD       0x03      // bit mask of timer0 mode\n// bT0_M1 & bT0_M0: timer0 mode\n//   00: mode 0, 13-bit timer or counter by cascaded TH0 and lower 5 bits of TL0, the upper 3 bits of TL0 are ignored\n//   01: mode 1, 16-bit timer or counter by cascaded TH0 and TL0\n//   10: mode 2, TL0 operates as 8-bit timer or counter, and TH0 provide initial value for TL0 auto-reload\n//   11: mode 3, TL0 is 8-bit timer or counter controlled by standard timer0 bits, TH0 is 8-bit timer using TF1 and controlled by TR1, timer1 run enable if it is not mode 3\nsfr TL0             = 0x8A;         // low byte of timer 0 count\nsfr TL1             = 0x8B;         // low byte of timer 1 count\nsfr TH0             = 0x8C;         // high byte of timer 0 count\nsfr TH1             = 0x8D;         // high byte of timer 1 count\n\n/*  UART0 Registers  */\nsfr SCON            = 0x98;         // UART0 control (serial port control)\n sbit SM0           = SCON^7;       // UART0 mode bit0, selection data bit: 0=8 bits data, 1=9 bits data\n sbit SM1           = SCON^6;       // UART0 mode bit1, selection baud rate: 0=fixed, 1=variable\n// SM0 & SM1: UART0 mode\n//    00 - mode 0, shift Register, baud rate fixed at: Fsys/12\n//    01 - mode 1, 8-bit UART,     baud rate = variable by timer1 or timer2 overflow rate\n//    10 - mode 2, 9-bit UART,     baud rate fixed at: Fsys/128@SMOD=0, Fsys/32@SMOD=1\n//    11 - mode 3, 9-bit UART,     baud rate = variable by timer1 or timer2 overflow rate\n sbit SM2           = SCON^5;       // enable multi-device communication in mode 2/3\n#define MASK_UART0_MOD    0xE0      // bit mask of UART0 mode\n sbit REN           = SCON^4;       // enable UART0 receiving\n sbit TB8           = SCON^3;       // the 9th transmitted data bit in mode 2/3\n sbit RB8           = SCON^2;       // 9th data bit received in mode 2/3, or stop bit received for mode 1\n sbit TI            = SCON^1;       // transmit interrupt flag, set by hardware after completion of a serial transmittal, need software clear\n sbit RI            = SCON^0;       // receive interrupt flag, set by hardware after completion of a serial receiving, need software clear\nsfr SBUF            = 0x99;         // UART0 data buffer: reading for receiving, writing for transmittal\n\n/*  Timer2/Capture Registers  */\nsfr T2CON2          = 0xC1;         // timer 2 extend control\n#define bT2_CAP0F         0x08      // timer2 capture 0 interrupt flag, set by CAP0 edge trigger if bT2_CAP0_EN=1, need software clear\n#define bT2_CAP0_EN       0x01      // enable CAP0 trigger function for capture 0 of timer2 if RCLK=0 & TCLK=0 & CP_RL2=1\nsfr16 T2CAP0        = 0xC6;         // ReadOnly: capture 0 value for timer2\nsfr T2CAP0L         = 0xC6;         // ReadOnly: capture 0 value low byte for timer2\nsfr T2CAP0H         = 0xC7;         // ReadOnly: capture 0 value high byte for timer2\nsfr T2CON           = 0xC8;         // timer 2 control\n sbit TF2           = T2CON^7;      // timer2 overflow & interrupt flag, need software clear, the flag will not be set when either RCLK=1 or TCLK=1\n sbit CAP1F         = T2CON^7;      // timer2 capture 1 interrupt flag, set by T2 edge trigger if bT2_CAP1_EN=1, need software clear\n sbit EXF2          = T2CON^6;      // timer2 external flag, set by T2EX edge trigger if EXEN2=1, need software clear\n sbit RCLK          = T2CON^5;      // selection UART0 receiving clock: 0=timer1 overflow pulse, 1=timer2 overflow pulse\n sbit TCLK          = T2CON^4;      // selection UART0 transmittal clock: 0=timer1 overflow pulse, 1=timer2 overflow pulse\n sbit EXEN2         = T2CON^3;      // enable T2EX trigger function: 0=ignore T2EX, 1=trigger reload or capture by T2EX edge\n sbit TR2           = T2CON^2;      // timer2 run enable\n sbit C_T2          = T2CON^1;      // timer2 clock source selection: 0=timer base internal clock, 1=external edge counter base T2 falling edge\n sbit CP_RL2        = T2CON^0;      // timer2 function selection (force 0 if RCLK=1 or TCLK=1): 0=timer and auto reload if count overflow or T2EX edge, 1=capture by T2EX edge\nsfr T2MOD           = 0xC9;         // timer 2 mode and timer 0/1/2 clock mode\n#define bTMR_CLK          0x80      // fastest internal clock mode for timer 0/1/2 under faster clock mode: 0=use divided clock, 1=use original Fsys as clock without dividing\n#define bT2_CLK           0x40      // timer2 internal clock frequency selection: 0=standard clock, Fsys/12 for timer mode, Fsys/4 for UART0 clock mode,\n                                    //   1=faster clock, Fsys/4 @bTMR_CLK=0 or Fsys @bTMR_CLK=1 for timer mode, Fsys/2 @bTMR_CLK=0 or Fsys @bTMR_CLK=1 for UART0 clock mode\n#define bT1_CLK           0x20      // timer1 internal clock frequency selection: 0=standard clock, Fsys/12, 1=faster clock, Fsys/4 if bTMR_CLK=0 or Fsys if bTMR_CLK=1\n#define bT0_CLK           0x10      // timer0 internal clock frequency selection: 0=standard clock, Fsys/12, 1=faster clock, Fsys/4 if bTMR_CLK=0 or Fsys if bTMR_CLK=1\n#define bT2_CAP_M1        0x08      // timer2 capture mode high bit\n#define bT2_CAP_M0        0x04      // timer2 capture mode low bit\n// bT2_CAP_M1 & bT2_CAP_M0: timer2 capture point selection\n//   x0: from falling edge to falling edge\n//   01: from any edge to any edge (level changing)\n//   11: from rising edge to rising edge\n#define T2OE              0x02      // enable timer2 generated clock output: 0=disable output, 1=enable clock output at T2 pin, frequency = TF2/2\n#define bT2_CAP1_EN       0x01      // enable T2 trigger function for capture 1 of timer2 if RCLK=0 & TCLK=0 & CP_RL2=1 & C_T2=0 & T2OE=0\nsfr16 RCAP2         = 0xCA;         // reload & capture value, little-endian\nsfr RCAP2L          = 0xCA;         // low byte of reload & capture value\nsfr RCAP2H          = 0xCB;         // high byte of reload & capture value\nsfr16 T2COUNT       = 0xCC;         // counter, little-endian\nsfr TL2             = 0xCC;         // low byte of timer 2 count\nsfr TH2             = 0xCD;         // high byte of timer 2 count\nsfr16 T2CAP1        = 0xCE;         // ReadOnly: capture 1 value for timer2\nsfr T2CAP1L         = 0xCE;         // ReadOnly: capture 1 value low byte for timer2\nsfr T2CAP1H         = 0xCF;         // ReadOnly: capture 1 value high byte for timer2\n\n/*  PWMX Registers  */\nsfr PWM_DATA2       = 0x9A;         // PWM data for PWM2\nsfr PWM_DATA1       = 0x9B;         // PWM data for PWM1\nsfr PWM_DATA0       = 0x9C;         // PWM data for PWM0\nsfr PWM_CTRL        = 0x9D;         // PWM control\n#define bPWM1_POLAR       0x40      // PWM1 output polarity: 0=default low and high action, 1=default high and low action\n#define bPWM0_POLAR       0x20      // PWM0 output polarity: 0=default low and high action, 1=default high and low action\n#define bPWM_IF_END       0x10      // interrupt flag for cycle end, write 1 to clear or load new data into PWM_DATA0 to clear\n#define bPWM1_OUT_EN      0x08      // PWM1 output enable\n#define bPWM0_OUT_EN      0x04      // PWM0 output enable\n#define bPWM_CLR_ALL      0x02      // force clear FIFO and count of PWMX\n#define bPWM_MOD_6BIT     0x01      // PWM data width mode: 0=8 bits data, 1=6 bits data\nsfr PWM_CK_SE       = 0x9E;         // clock divisor setting\nsfr PWM_CTRL2       = 0x9F;         // PWM extend control\n#define bPWM7_OUT_EN      0x20      // PWM7 output enable\n#define bPWM6_OUT_EN      0x10      // PWM6 output enable\n#define bPWM5_OUT_EN      0x08      // PWM5 output enable\n#define bPWM4_OUT_EN      0x04      // PWM4 output enable\n#define bPWM3_OUT_EN      0x02      // PWM3 output enable\n#define bPWM2_OUT_EN      0x01      // PWM2 output enable\nsfr PWM_DATA3       = 0xA3;         // PWM data for PWM3\nsfr PWM_DATA4       = 0xA4;         // PWM data for PWM4\nsfr PWM_DATA5       = 0xA5;         // PWM data for PWM5\nsfr PWM_DATA6       = 0xA6;         // PWM data for PWM6\nsfr PWM_DATA7       = 0xA7;         // PWM data for PWM7\n\n/*  SPI0/Master0/Slave Registers  */\nsfr SPI0_STAT       = 0xF8;         // SPI 0 status\n sbit S0_FST_ACT    = SPI0_STAT^7;  // ReadOnly: indicate first byte received status for SPI0\n sbit S0_IF_OV      = SPI0_STAT^6;  // interrupt flag for slave mode FIFO overflow, direct bit address clear or write 1 to clear\n sbit S0_IF_FIRST   = SPI0_STAT^5;  // interrupt flag for first byte received, direct bit address clear or write 1 to clear\n sbit S0_IF_BYTE    = SPI0_STAT^4;  // interrupt flag for a byte data exchanged, direct bit address clear or write 1 to clear or accessing FIFO to clear if bS0_AUTO_IF=1\n sbit S0_FREE       = SPI0_STAT^3;  // ReadOnly: SPI0 free status\n sbit S0_T_FIFO     = SPI0_STAT^2;  // ReadOnly: tx FIFO count for SPI0\n sbit S0_R_FIFO     = SPI0_STAT^0;  // ReadOnly: rx FIFO count for SPI0\nsfr SPI0_DATA       = 0xF9;         // FIFO data port: reading for receiving, writing for transmittal\nsfr SPI0_CTRL       = 0xFA;         // SPI 0 control\n#define bS0_MISO_OE       0x80      // SPI0 MISO output enable\n#define bS0_MOSI_OE       0x40      // SPI0 MOSI output enable\n#define bS0_SCK_OE        0x20      // SPI0 SCK output enable\n#define bS0_DATA_DIR      0x10      // SPI0 data direction: 0=out(master_write), 1=in(master_read)\n#define bS0_MST_CLK       0x08      // SPI0 master clock mode: 0=mode 0 with default low, 1=mode 3 with default high\n#define bS0_2_WIRE        0x04      // enable SPI0 two wire mode: 0=3 wire (SCK+MOSI+MISO), 1=2 wire (SCK+MISO)\n#define bS0_CLR_ALL       0x02      // force clear FIFO and count of SPI0\n#define bS0_AUTO_IF       0x01      // enable FIFO accessing to auto clear S0_IF_BYTE interrupt flag\nsfr SPI0_CK_SE      = 0xFB;         // clock divisor setting\n//sfr SPI0_S_PRE      = 0xFB;         // preset value for SPI slave\n#define SPI0_S_PRE        SPI0_CK_SE\nsfr SPI0_SETUP      = 0xFC;         // SPI 0 setup\n#define bS0_MODE_SLV      0x80      // SPI0 slave mode: 0=master, 1=slave\n#define bS0_IE_FIFO_OV    0x40      // enable interrupt for slave mode FIFO overflow\n#define bS0_IE_FIRST      0x20      // enable interrupt for first byte received for SPI0 slave mode\n#define bS0_IE_BYTE       0x10      // enable interrupt for a byte received\n#define bS0_BIT_ORDER     0x08      // SPI0 bit data order: 0=MSB first, 1=LSB first\n#define bS0_SLV_SELT      0x02      // ReadOnly: SPI0 slave mode chip selected status: 0=unselected, 1=selected\n#define bS0_SLV_PRELOAD   0x01      // ReadOnly: SPI0 slave mode data pre-loading status just after chip-selection\n\n/*  UART1 Registers  */\nsfr SCON1           = 0xBC;         // UART1 control (serial port control)\n#define bU1SM0            0x80      // UART1 mode, selection data bit: 0=8 bits data, 1=9 bits data\n#define bU1SMOD           0x20      // UART1 2X baud rate selection: 0=slow(Fsys/32/(256-SBAUD1)), 1=fast(Fsys/16/(256-SBAUD1))\n#define bU1REN            0x10      // enable UART1 receiving\n#define bU1TB8            0x08      // the 9th transmitted data bit in 9 bits data mode\n#define bU1RB8            0x04      // 9th data bit received in 9 bits data mode, or stop bit received for 8 bits data mode\n#define bU1TIS            0x02      // WriteOnly: write 1 to preset transmit interrupt flag\n#define bU1RIS            0x01      // WriteOnly: write 1 to preset receive interrupt flag\nsfr SBUF1           = 0xBD;         // UART1 data buffer: reading for receiving, writing for transmittal\nsfr SBAUD1          = 0xBE;         // UART1 baud rate setting\nsfr SIF1            = 0xBF;         // UART1 interrupt flag\n#define bU1TI             0x02      // transmit interrupt flag, set by hardware after completion of a serial transmittal, need software write 1 to clear\n#define bU1RI             0x01      // receive interrupt flag, set by hardware after completion of a serial receiving, need software write 1 to clear\n\n/*  UART2 Registers  */\nsfr SCON2           = 0xB4;         // UART2 control (serial port control)\n#define bU2SM0            0x80      // UART2 mode, selection data bit: 0=8 bits data, 1=9 bits data\n#define bU2IE             0x40      // UART2 interrupt enable: 0=disable interrupt, 1=enable interrupt instead of ADC\n#define bU2SMOD           0x20      // UART2 2X baud rate selection: 0=slow(Fsys/32/(256-SBAUD2)), 1=fast(Fsys/16/(256-SBAUD2))\n#define bU2REN            0x10      // enable UART2 receiving\n#define bU2TB8            0x08      // the 9th transmitted data bit in 9 bits data mode\n#define bU2RB8            0x04      // 9th data bit received in 9 bits data mode, or stop bit received for 8 bits data mode\n#define bU2TIS            0x02      // WriteOnly: write 1 to preset transmit interrupt flag\n#define bU2RIS            0x01      // WriteOnly: write 1 to preset receive interrupt flag\nsfr SBUF2           = 0xB5;         // UART2 data buffer: reading for receiving, writing for transmittal\nsfr SBAUD2          = 0xB6;         // UART2 baud rate setting\nsfr SIF2            = 0xB7;         // UART2 interrupt flag\n#define bU2TI             0x02      // transmit interrupt flag, set by hardware after completion of a serial transmittal, need software write 1 to clear\n#define bU2RI             0x01      // receive interrupt flag, set by hardware after completion of a serial receiving, need software write 1 to clear\n\n/*  UART3 Registers  */\nsfr SCON3           = 0xAC;         // UART3 control (serial port control)\n#define bU3SM0            0x80      // UART3 mode, selection data bit: 0=8 bits data, 1=9 bits data\n#define bU3IE             0x40      // UART3 interrupt enable: 0=disable interrupt, 1=enable interrupt instead of PWMX\n#define bU3SMOD           0x20      // UART3 2X baud rate selection: 0=slow(Fsys/32/(256-SBAUD3)), 1=fast(Fsys/16/(256-SBAUD3))\n#define bU3REN            0x10      // enable UART3 receiving\n#define bU3TB8            0x08      // the 9th transmitted data bit in 9 bits data mode\n#define bU3RB8            0x04      // 9th data bit received in 9 bits data mode, or stop bit received for 8 bits data mode\n#define bU3TIS            0x02      // WriteOnly: write 1 to preset transmit interrupt flag\n#define bU3RIS            0x01      // WriteOnly: write 1 to preset receive interrupt flag\nsfr SBUF3           = 0xAD;         // UART3 data buffer: reading for receiving, writing for transmittal\nsfr SBAUD3          = 0xAE;         // UART3 baud rate setting\nsfr SIF3            = 0xAF;         // UART3 interrupt flag\n#define bU3TI             0x02      // transmit interrupt flag, set by hardware after completion of a serial transmittal, need software write 1 to clear\n#define bU3RI             0x01      // receive interrupt flag, set by hardware after completion of a serial receiving, need software write 1 to clear\n\n/*  ADC and comparator and touch-key Registers  */\nsfr TKEY_CTRL       = 0xF1;         // WriteOnly: touch-key charging pulse width control (only low 7 bits valid), auto cleared\nsfr ADC_CTRL        = 0xF2;         // ADC control and status\n#define bCMPDO            0x80      // ReadOnly: comparator result synchronous delay input\n#define bCMP_IF           0x40      // interrupt flag for comparator result changed, write 1 to clear\n#define bADC_IF           0x20      // interrupt flag for ADC finished, write 1 to clear or write TKEY_CTRL to clear\n#define bADC_START        0x10      // set 1 to start ADC, auto cleared when ADC finished\n#define bTKEY_ACT         0x08      // ReadOnly: indicate touch-key running status (charge then ADC)\n#define bCMPO             0x01      // ReadOnly: comparator result real time input\nsfr ADC_CFG         = 0xF3;         // ADC config\n#define bADC_AIN_EN       0x20      // enable external AIN on ADC/comparator IN+ channel: 0=disable AIN on ADC/comparator IN+ channel, 1=enable external AIN by MASK_ADC_CHAN\n#define bVDD_REF_EN       0x10      // enable internal VDD reference voltage: 0=disable VDD resistances, 1=enable VDD series connection resistances to get internal reference voltage\n#define bADC_EN           0x08      // control ADC power: 0=shut down ADC, 1=enable power for ADC\n#define bCMP_EN           0x04      // control comparator power: 0=shut down comparator, 1=enable power for comparator, auto wake-up if comparator result changed\n#define bADC_CLK1         0x02      // ADC clock frequency selection high bit\n#define bADC_CLK0         0x01      // ADC clock frequency selection low bit\n// bADC_CLK1 & bADC_CLK0: ADC clock frequency selection\n//   00: slowest clock, 512 Fosc cycles for each ADC\n//   01: slower clock, 256 Fosc cycles for each ADC\n//   10: faster clock, 128 Fosc cycles for each ADC\n//   11: fastest clock, 64 Fosc cycles for each ADC\nsfr16 ADC_DAT       = 0xF4;         // ReadOnly: ADC data\nsfr ADC_DAT_L       = 0xF4;         // ReadOnly: ADC data low byte\nsfr ADC_DAT_H       = 0xF5;         // ReadOnly: ADC data high byte (only low 4 bits valid)\nsfr ADC_CHAN        = 0xF6;         // ADC analog signal channel seletion\n#define MASK_CMP_CHAN     0xC0      // bit mask of comparator IN- input signal channel selection\n// bCMP_EN & bVDD_REF_EN & MASK_CMP_CHAN[1] & [0]: comparator IN- input signal channel selection\n//   0xxx: disconnect / float\n//   1000: disconnect / float\n//   1100: connect VDD/8\n//   1001: connect VDD\n//   1101: connect VDD/4\n//   1x10: connect AIN1(P1.1)\n//   1x11: connect AIN2(P1.2)\n#define MASK_ADC_I_CH     0x30      // bit mask of ADC/comparator IN+ input internal signal channel selection\n// bADC_EN & bADC_AIN_EN & bVDD_REF_EN & MASK_ADC_I_CH[1] & [0]: ADC/comparator IN+ input internal signal channel selection\n//   xx000: disconnect internal signal / float\n//   xx100: connect VDD/2\n//   xxx01: connect V33\n//   xxx10: connect V33/1.83\n//   10x11: connect temperature sense\n//   0xx11: disconnect internal signal / float\n//   x1x11: disconnect internal signal / float\n#define MASK_ADC_CHAN     0x0F      // bit mask of ADC/comparator IN+ input external signal channel selection if bADC_AIN_EN=1\n// bADC_AIN_EN & MASK_ADC_CHAN[3] & [2] & [1] & [0]: ADC/comparator IN+ input external signal channel selection\n//   0xxxx: disconnect external signal AIN0~AIN15 / float\n//   10000: connect AIN0(P1.0)\n//   10001: connect AIN1(P1.1)\n//   10010: connect AIN2(P1.2)\n//   10011: connect AIN3(P1.3)\n//   10100: connect AIN4(P1.4)\n//   10101: connect AIN5(P1.5)\n//   10110: connect AIN6(P1.6)\n//   10111: connect AIN7(P1.7)\n//   11000: connect AIN8(P0.0)\n//   11001: connect AIN9(P0.1)\n//   11010: connect AIN10(P0.2)\n//   11011: connect AIN11(P0.3)\n//   11100: connect AIN12(P0.4)\n//   11101: connect AIN13(P0.5)\n//   11110: connect AIN14(P0.6)\n//   11111: connect AIN15(P0.7)\nsfr ADC_PIN         = 0xF7;         // ADC pin digital input control\n#define bAIN14_15_DI_DIS  0x80      // control AIN14/AIN15 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN12_13_DI_DIS  0x40      // control AIN12/AIN13 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN10_11_DI_DIS  0x20      // control AIN10/AIN11 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN8_9_DI_DIS    0x10      // control AIN8/AIN9 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN6_7_DI_DIS    0x08      // control AIN6/AIN7 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN4_5_DI_DIS    0x04      // control AIN4/AIN5 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN2_3_DI_DIS    0x02      // control AIN2/AIN3 digital input: 0=enable digital input, 1=disable digital input\n#define bAIN0_1_DI_DIS    0x01      // control AIN0/AIN1 digital input: 0=enable digital input, 1=disable digital input\n\n/*  USB/Host/Device Registers  */\nsfr USB_C_CTRL      = 0x91;         // USB type-C control\n#define bUCC_PD_MOD       0x80      // USB UCC1/UCC2 power delivery BMC output mode enable: 0=disable, 1=enable PD output mode\n#define bUCC2_PD_EN       0x40      // USB UCC2 5.1K pulldown resistance: 0=disable, 1=enable pulldown\n#define bUCC2_PU1_EN      0x20      // USB UCC2 pullup resistance control high bit\n#define bUCC2_PU0_EN      0x10      // USB UCC2 pullup resistance control low bit\n#define bVBUS_PD_EN       0x08      // USB VBUS 10K pulldown resistance: 0=disable, 1=enable pullup\n#define bUCC1_PD_EN       0x04      // USB UCC1 5.1K pulldown resistance: 0=disable, 1=enable pulldown\n#define bUCC1_PU1_EN      0x02      // USB UCC1 pullup resistance control high bit\n#define bUCC1_PU0_EN      0x01      // USB UCC1 pullup resistance control low bit\n// bUCC?_PU1_EN & bUCC?_PU0_EN: USB CC pullup resistance selection\n//   00: disable pullup resistance\n//   01: enable 56K pullup resistance for default USB power\n//   10: enable 22K pullup resistance for 1.5A USB power\n//   11: enable 10K pullup resistance for 3A USB power\nsfr UDEV_CTRL       = 0xD1;         // USB device physical port control\n#define bUD_PD_DIS        0x80      // disable USB UDP/UDM pulldown resistance: 0=enable pulldown, 1=disable\n#define bUD_DP_PIN        0x20      // ReadOnly: indicate current UDP pin level\n#define bUD_DM_PIN        0x10      // ReadOnly: indicate current UDM pin level\n#define bUD_LOW_SPEED     0x04      // enable USB physical port low speed: 0=full speed, 1=low speed\n#define bUD_GP_BIT        0x02      // general purpose bit\n#define bUD_PORT_EN       0x01      // enable USB physical port I/O: 0=disable, 1=enable\n//sfr UHOST_CTRL      = 0xD1;         // USB host physical port control\n#define UHOST_CTRL        UDEV_CTRL\n#define bUH_PD_DIS        0x80      // disable USB UDP/UDM pulldown resistance: 0=enable pulldown, 1=disable\n#define bUH_DP_PIN        0x20      // ReadOnly: indicate current UDP pin level\n#define bUH_DM_PIN        0x10      // ReadOnly: indicate current UDM pin level\n#define bUH_LOW_SPEED     0x04      // enable USB port low speed: 0=full speed, 1=low speed\n#define bUH_BUS_RESET     0x02      // control USB bus reset: 0=normal, 1=force bus reset\n#define bUH_PORT_EN       0x01      // enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached\nsfr UEP1_CTRL       = 0xD2;         // endpoint 1 control\n#define bUEP_R_TOG        0x80      // expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1\n#define bUEP_T_TOG        0x40      // prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1\n#define bUEP_AUTO_TOG     0x10      // enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle\n#define bUEP_R_RES1       0x08      // handshake response type high bit for USB endpoint X receiving (OUT)\n#define bUEP_R_RES0       0x04      // handshake response type low bit for USB endpoint X receiving (OUT)\n#define MASK_UEP_R_RES    0x0C      // bit mask of handshake response type for USB endpoint X receiving (OUT)\n#define UEP_R_RES_ACK     0x00\n#define UEP_R_RES_TOUT    0x04\n#define UEP_R_RES_NAK     0x08\n#define UEP_R_RES_STALL   0x0C\n// bUEP_R_RES1 & bUEP_R_RES0: handshake response type for USB endpoint X receiving (OUT)\n//   00: ACK (ready)\n//   01: no response, time out to host, for non-zero endpoint isochronous transactions\n//   10: NAK (busy)\n//   11: STALL (error)\n#define bUEP_T_RES1       0x02      // handshake response type high bit for USB endpoint X transmittal (IN)\n#define bUEP_T_RES0       0x01      // handshake response type low bit for USB endpoint X transmittal (IN)\n#define MASK_UEP_T_RES    0x03      // bit mask of handshake response type for USB endpoint X transmittal (IN)\n#define UEP_T_RES_ACK     0x00\n#define UEP_T_RES_TOUT    0x01\n#define UEP_T_RES_NAK     0x02\n#define UEP_T_RES_STALL   0x03\n// bUEP_T_RES1 & bUEP_T_RES0: handshake response type for USB endpoint X transmittal (IN)\n//   00: DATA0 or DATA1 then expecting ACK (ready)\n//   01: DATA0 or DATA1 then expecting no response, time out from host, for non-zero endpoint isochronous transactions\n//   10: NAK (busy)\n//   11: STALL (error)\nsfr UEP1_T_LEN      = 0xD3;         // endpoint 1 transmittal length\nsfr UEP2_CTRL       = 0xD4;         // endpoint 2 control\nsfr UEP2_T_LEN      = 0xD5;         // endpoint 2 transmittal length\nsfr UEP3_CTRL       = 0xD6;         // endpoint 3 control\nsfr UEP3_T_LEN      = 0xD7;         // endpoint 3 transmittal length\nsfr USB_INT_FG      = 0xD8;         // USB interrupt flag\n sbit U_IS_NAK      = USB_INT_FG^7; // ReadOnly: indicate current USB transfer is NAK received\n sbit U_TOG_OK      = USB_INT_FG^6; // ReadOnly: indicate current USB transfer toggle is OK\n sbit U_SIE_FREE    = USB_INT_FG^5; // ReadOnly: indicate USB SIE free status\n sbit UIF_FIFO_OV   = USB_INT_FG^4; // FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear\n sbit UIF_HST_SOF   = USB_INT_FG^3; // host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear\n sbit UIF_SUSPEND   = USB_INT_FG^2; // USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear\n sbit UIF_TRANSFER  = USB_INT_FG^1; // USB transfer completion interrupt flag, direct bit address clear or write 1 to clear\n sbit UIF_DETECT    = USB_INT_FG^0; // device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear\n sbit UIF_BUS_RST   = USB_INT_FG^0; // bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear\nsfr USB_INT_ST      = 0xD9;         // ReadOnly: USB interrupt status\n#define bUIS_IS_NAK       0x80      // ReadOnly: indicate current USB transfer is NAK received for USB device mode\n#define bUIS_TOG_OK       0x40      // ReadOnly: indicate current USB transfer toggle is OK\n#define bUIS_TOKEN1       0x20      // ReadOnly: current token PID code bit 1 received for USB device mode\n#define bUIS_TOKEN0       0x10      // ReadOnly: current token PID code bit 0 received for USB device mode\n#define MASK_UIS_TOKEN    0x30      // ReadOnly: bit mask of current token PID code received for USB device mode\n#define UIS_TOKEN_OUT     0x00\n#define UIS_TOKEN_SOF     0x10\n#define UIS_TOKEN_IN      0x20\n#define UIS_TOKEN_SETUP   0x30\n// bUIS_TOKEN1 & bUIS_TOKEN0: current token PID code received for USB device mode\n//   00: OUT token PID received\n//   01: SOF token PID received\n//   10: IN token PID received\n//   11: SETUP token PID received\n#define MASK_UIS_ENDP     0x0F      // ReadOnly: bit mask of current transfer endpoint number for USB device mode\n#define MASK_UIS_H_RES    0x0F      // ReadOnly: bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received\nsfr USB_MIS_ST      = 0xDA;         // ReadOnly: USB miscellaneous status\n#define bUMS_SOF_PRES     0x80      // ReadOnly: indicate host SOF timer presage status\n#define bUMS_SOF_ACT      0x40      // ReadOnly: indicate host SOF timer action status for USB host\n#define bUMS_SIE_FREE     0x20      // ReadOnly: indicate USB SIE free status\n#define bUMS_R_FIFO_RDY   0x10      // ReadOnly: indicate USB receiving FIFO ready status (not empty)\n#define bUMS_BUS_RESET    0x08      // ReadOnly: indicate USB bus reset status\n#define bUMS_SUSPEND      0x04      // ReadOnly: indicate USB suspend status\n#define bUMS_DM_LEVEL     0x02      // ReadOnly: indicate UDM level saved at device attached to USB host\n#define bUMS_DEV_ATTACH   0x01      // ReadOnly: indicate device attached status on USB host\nsfr USB_RX_LEN      = 0xDB;         // ReadOnly: USB receiving length\nsfr UEP0_CTRL       = 0xDC;         // endpoint 0 control\nsfr UEP0_T_LEN      = 0xDD;         // endpoint 0 transmittal length\nsfr UEP4_CTRL       = 0xDE;         // endpoint 4 control\nsfr UEP4_T_LEN      = 0xDF;         // endpoint 4 transmittal length\nsfr USB_INT_EN      = 0xE1;         // USB interrupt enable\n#define bUIE_DEV_SOF      0x80      // enable interrupt for SOF received for USB device mode\n#define bUIE_DEV_NAK      0x40      // enable interrupt for NAK responded for USB device mode\n#define bUIE_FIFO_OV      0x10      // enable interrupt for FIFO overflow\n#define bUIE_HST_SOF      0x08      // enable interrupt for host SOF timer action for USB host mode\n#define bUIE_SUSPEND      0x04      // enable interrupt for USB suspend or resume event\n#define bUIE_TRANSFER     0x02      // enable interrupt for USB transfer completion\n#define bUIE_DETECT       0x01      // enable interrupt for USB device detected event for USB host mode\n#define bUIE_BUS_RST      0x01      // enable interrupt for USB bus reset event for USB device mode\nsfr USB_CTRL        = 0xE2;         // USB base control\n#define bUC_HOST_MODE     0x80      // enable USB host mode: 0=device mode, 1=host mode\n#define bUC_LOW_SPEED     0x40      // enable USB low speed: 0=full speed, 1=low speed\n#define bUC_DEV_PU_EN     0x20      // USB device enable and internal pullup resistance enable\n#define bUC_SYS_CTRL1     0x20      // USB system control high bit\n#define bUC_SYS_CTRL0     0x10      // USB system control low bit\n#define MASK_UC_SYS_CTRL  0x30      // bit mask of USB system control\n// bUC_HOST_MODE & bUC_SYS_CTRL1 & bUC_SYS_CTRL0: USB system control\n//   0 00: disable USB device and disable internal pullup resistance\n//   0 01: enable USB device and disable internal pullup resistance, need external pullup resistance\n//   0 1x: enable USB device and enable internal pullup resistance\n//   1 00: enable USB host and normal status\n//   1 01: enable USB host and force UDP/UDM output SE0 state\n//   1 10: enable USB host and force UDP/UDM output J state\n//   1 11: enable USB host and force UDP/UDM output resume or K state\n#define bUC_INT_BUSY      0x08      // enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid\n#define bUC_RESET_SIE     0x04      // force reset USB SIE, need software clear\n#define bUC_CLR_ALL       0x02      // force clear FIFO and count of USB\n#define bUC_DMA_EN        0x01      // DMA enable and DMA interrupt enable for USB\nsfr USB_DEV_AD      = 0xE3;         // USB device address, lower 7 bits for USB device address\n#define bUDA_GP_BIT       0x80      // general purpose bit\n#define MASK_USB_ADDR     0x7F      // bit mask for USB device address\nsfr16 UEP2_DMA      = 0xE4;         // endpoint 2 buffer start address, little-endian\nsfr UEP2_DMA_L      = 0xE4;         // endpoint 2 buffer start address low byte\nsfr UEP2_DMA_H      = 0xE5;         // endpoint 2 buffer start address high byte\nsfr16 UEP3_DMA      = 0xE6;         // endpoint 3 buffer start address, little-endian\nsfr UEP3_DMA_L      = 0xE6;         // endpoint 3 buffer start address low byte\nsfr UEP3_DMA_H      = 0xE7;         // endpoint 3 buffer start address high byte\nsfr UEP4_1_MOD      = 0xEA;         // endpoint 4/1 mode\n#define bUEP1_RX_EN       0x80      // enable USB endpoint 1 receiving (OUT)\n#define bUEP1_TX_EN       0x40      // enable USB endpoint 1 transmittal (IN)\n#define bUEP1_BUF_MOD     0x10      // buffer mode of USB endpoint 1\n// bUEPn_RX_EN & bUEPn_TX_EN & bUEPn_BUF_MOD: USB endpoint 1/2/3 buffer mode, buffer start address is UEPn_DMA\n//   0 0 x:  disable endpoint and disable buffer\n//   1 0 0:  64 bytes buffer for receiving (OUT endpoint)\n//   1 0 1:  dual 64 bytes buffer by toggle bit bUEP_R_TOG selection for receiving (OUT endpoint), total=128bytes\n//   0 1 0:  64 bytes buffer for transmittal (IN endpoint)\n//   0 1 1:  dual 64 bytes buffer by toggle bit bUEP_T_TOG selection for transmittal (IN endpoint), total=128bytes\n//   1 1 0:  64 bytes buffer for receiving (OUT endpoint) + 64 bytes buffer for transmittal (IN endpoint), total=128bytes\n//   1 1 1:  dual 64 bytes buffer by bUEP_R_TOG selection for receiving (OUT endpoint) + dual 64 bytes buffer by bUEP_T_TOG selection for transmittal (IN endpoint), total=256bytes\n#define bUEP4_RX_EN       0x08      // enable USB endpoint 4 receiving (OUT)\n#define bUEP4_TX_EN       0x04      // enable USB endpoint 4 transmittal (IN)\n// bUEP4_RX_EN & bUEP4_TX_EN: USB endpoint 4 buffer mode, buffer start address is UEP0_DMA\n//   0 0:  single 64 bytes buffer for endpoint 0 receiving & transmittal (OUT & IN endpoint)\n//   1 0:  single 64 bytes buffer for endpoint 0 receiving & transmittal (OUT & IN endpoint) + 64 bytes buffer for endpoint 4 receiving (OUT endpoint), total=128bytes\n//   0 1:  single 64 bytes buffer for endpoint 0 receiving & transmittal (OUT & IN endpoint) + 64 bytes buffer for endpoint 4 transmittal (IN endpoint), total=128bytes\n//   1 1:  single 64 bytes buffer for endpoint 0 receiving & transmittal (OUT & IN endpoint)\n//           + 64 bytes buffer for endpoint 4 receiving (OUT endpoint) + 64 bytes buffer for endpoint 4 transmittal (IN endpoint), total=192bytes\nsfr UEP2_3_MOD      = 0xEB;         // endpoint 2/3 mode\n#define bUEP3_RX_EN       0x80      // enable USB endpoint 3 receiving (OUT)\n#define bUEP3_TX_EN       0x40      // enable USB endpoint 3 transmittal (IN)\n#define bUEP3_BUF_MOD     0x10      // buffer mode of USB endpoint 3\n#define bUEP2_RX_EN       0x08      // enable USB endpoint 2 receiving (OUT)\n#define bUEP2_TX_EN       0x04      // enable USB endpoint 2 transmittal (IN)\n#define bUEP2_BUF_MOD     0x01      // buffer mode of USB endpoint 2\nsfr16 UEP0_DMA      = 0xEC;         // endpoint 0 buffer start address, little-endian\nsfr UEP0_DMA_L      = 0xEC;         // endpoint 0 buffer start address low byte\nsfr UEP0_DMA_H      = 0xED;         // endpoint 0 buffer start address high byte\nsfr16 UEP1_DMA      = 0xEE;         // endpoint 1 buffer start address, little-endian\nsfr UEP1_DMA_L      = 0xEE;         // endpoint 1 buffer start address low byte\nsfr UEP1_DMA_H      = 0xEF;         // endpoint 1 buffer start address high byte\n//sfr UH_SETUP        = 0xD2;         // host aux setup\n#define UH_SETUP          UEP1_CTRL\n#define bUH_PRE_PID_EN    0x80      // USB host PRE PID enable for low speed device via hub\n#define bUH_SOF_EN        0x40      // USB host automatic SOF enable\n//sfr UH_RX_CTRL      = 0xD4;         // host receiver endpoint control\n#define UH_RX_CTRL        UEP2_CTRL\n#define bUH_R_TOG         0x80      // expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1\n#define bUH_R_AUTO_TOG    0x10      // enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle\n#define bUH_R_RES         0x04      // prepared handshake response type for host receiving (IN): 0=ACK (ready), 1=no response, time out to device, for isochronous transactions\n//sfr UH_EP_PID       = 0xD5;         // host endpoint and token PID, lower 4 bits for endpoint number, upper 4 bits for token PID\n#define UH_EP_PID         UEP2_T_LEN\n#define MASK_UH_TOKEN     0xF0      // bit mask of token PID for USB host transfer\n#define MASK_UH_ENDP      0x0F      // bit mask of endpoint number for USB host transfer\n//sfr UH_TX_CTRL      = 0xD6;         // host transmittal endpoint control\n#define UH_TX_CTRL        UEP3_CTRL\n#define bUH_T_TOG         0x40      // prepared data toggle flag of host transmittal (SETUP/OUT): 0=DATA0, 1=DATA1\n#define bUH_T_AUTO_TOG    0x10      // enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle\n#define bUH_T_RES         0x01      // expected handshake response type for host transmittal (SETUP/OUT): 0=ACK (ready), 1=no response, time out from device, for isochronous transactions\n//sfr UH_TX_LEN       = 0xD7;         // host transmittal endpoint transmittal length\n#define UH_TX_LEN         UEP3_T_LEN\n//sfr UH_EP_MOD       = 0xEB;         // host endpoint mode\n#define UH_EP_MOD         UEP2_3_MOD\n#define bUH_EP_TX_EN      0x40      // enable USB host OUT endpoint transmittal\n#define bUH_EP_TBUF_MOD   0x10      // buffer mode of USB host OUT endpoint\n// bUH_EP_TX_EN & bUH_EP_TBUF_MOD: USB host OUT endpoint buffer mode, buffer start address is UH_TX_DMA\n//   0 x:  disable endpoint and disable buffer\n//   1 0:  64 bytes buffer for transmittal (OUT endpoint)\n//   1 1:  dual 64 bytes buffer by toggle bit bUH_T_TOG selection for transmittal (OUT endpoint), total=128bytes\n#define bUH_EP_RX_EN      0x08      // enable USB host IN endpoint receiving\n#define bUH_EP_RBUF_MOD   0x01      // buffer mode of USB host IN endpoint\n// bUH_EP_RX_EN & bUH_EP_RBUF_MOD: USB host IN endpoint buffer mode, buffer start address is UH_RX_DMA\n//   0 x:  disable endpoint and disable buffer\n//   1 0:  64 bytes buffer for receiving (IN endpoint)\n//   1 1:  dual 64 bytes buffer by toggle bit bUH_R_TOG selection for receiving (IN endpoint), total=128bytes\n//sfr16 UH_RX_DMA     = 0xE4;         // host rx endpoint buffer start address, little-endian\n#define UH_RX_DMA         UEP2_DMA\n//sfr UH_RX_DMA_L     = 0xE4;         // host rx endpoint buffer start address low byte\n#define UH_RX_DMA_L       UEP2_DMA_L\n//sfr UH_RX_DMA_H     = 0xE5;         // host rx endpoint buffer start address high byte\n#define UH_RX_DMA_H       UEP2_DMA_H\n//sfr16 UH_TX_DMA     = 0xE6;         // host tx endpoint buffer start address, little-endian\n#define UH_TX_DMA         UEP3_DMA\n//sfr UH_TX_DMA_L     = 0xE6;         // host tx endpoint buffer start address low byte\n#define UH_TX_DMA_L       UEP3_DMA_L\n//sfr UH_TX_DMA_H     = 0xE7;         // host tx endpoint buffer start address high byte\n#define UH_TX_DMA_H       UEP3_DMA_H\n\n/*----- XDATA: xRAM ------------------------------------------*/\n\n#define XDATA_RAM_SIZE    0x0800    // size of expanded xRAM, xdata SRAM embedded chip\n\n/*----- Reference Information --------------------------------------------*/\n#define ID_CH549          0x49      // chip ID\n#define ID_CH548          0x48      // chip ID\n\n/* Interrupt routine address and interrupt number */\n#define INT_ADDR_INT0     0x0003    // interrupt vector address for INT0\n#define INT_ADDR_TMR0     0x000B    // interrupt vector address for timer0\n#define INT_ADDR_INT1     0x0013    // interrupt vector address for INT1\n#define INT_ADDR_TMR1     0x001B    // interrupt vector address for timer1\n#define INT_ADDR_UART0    0x0023    // interrupt vector address for UART0\n#define INT_ADDR_TMR2     0x002B    // interrupt vector address for timer2\n#define INT_ADDR_SPI0     0x0033    // interrupt vector address for SPI0\n#define INT_ADDR_INT3     0x003B    // interrupt vector address for INT3\n#define INT_ADDR_USB      0x0043    // interrupt vector address for USB\n#define INT_ADDR_ADC      0x004B    // interrupt vector address for ADC/UART2\n#define INT_ADDR_UART2    0x004B    // interrupt vector address for ADC/UART2\n#define INT_ADDR_UART1    0x0053    // interrupt vector address for UART1\n#define INT_ADDR_PWMX     0x005B    // interrupt vector address for PWMX/UART3\n#define INT_ADDR_UART3    0x005B    // interrupt vector address for PWMX/UART3\n#define INT_ADDR_GPIO     0x0063    // interrupt vector address for GPIO\n#define INT_ADDR_WDOG     0x006B    // interrupt vector address for watch-dog timer\n#define INT_NO_INT0       0         // interrupt number for INT0\n#define INT_NO_TMR0       1         // interrupt number for timer0\n#define INT_NO_INT1       2         // interrupt number for INT1\n#define INT_NO_TMR1       3         // interrupt number for timer1\n#define INT_NO_UART0      4         // interrupt number for UART0\n#define INT_NO_TMR2       5         // interrupt number for timer2\n#define INT_NO_SPI0       6         // interrupt number for SPI0\n#define INT_NO_INT3       7         // interrupt number for INT3\n#define INT_NO_USB        8         // interrupt number for USB\n#define INT_NO_ADC        9         // interrupt number for ADC/UART2\n#define INT_NO_UART2      9         // interrupt number for ADC/UART2\n#define INT_NO_UART1      10        // interrupt number for UART1\n#define INT_NO_PWMX       11        // interrupt number for PWMX/UART3\n#define INT_NO_UART3      11        // interrupt number for PWMX/UART3\n#define INT_NO_GPIO       12        // interrupt number for GPIO\n#define INT_NO_WDOG       13        // interrupt number for watch-dog timer\n\n/* Special Program Space */\n#define DATA_FLASH_ADDR   0xF000    // start address of Data-Flash\n#define BOOT_LOAD_ADDR    0xF400    // start address of boot loader program\n#define ROM_CFG_ADDR      0xFFFE    // chip configuration information address\n#define ROM_CHIP_ID_LO    0x10      // chip ID number low dword\n#define ROM_CHIP_ID_HI    0x14      // chip ID number high dword\n\n/*\nNew Instruction:   MOVX @DPTR1,A\nInstruction Code:  0xA5\nInstruction Cycle: 1\nInstruction Operation:\n   step-1. write ACC @DPTR1 into xdata SRAM embedded chip\n   step-2. increase DPTR1\nASM example:\n       INC  XBUS_AUX\n       MOV  DPTR,#TARGET_ADDR ;DPTR1\n       DEC  XBUS_AUX\n       MOV  DPTR,#SOURCE_ADDR ;DPTR0\n       MOV  R7,#xxH\n LOOP: MOVX A,@DPTR ;DPTR0\n       INC  DPTR    ;DPTR0, if need\n       DB   0A5H    ;MOVX @DPTR1,A & INC DPTR1\n       DJNZ R7,LOOP\n*/\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // __CH549_H__\n\n#ifndef __USB_DEF__\n#define __USB_DEF__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*----- USB constant and structure define --------------------------------*/\n\n/* USB PID */\n#ifndef USB_PID_SETUP\n#define USB_PID_NULL            0x00    /* reserved PID */\n#define USB_PID_SOF             0x05\n#define USB_PID_SETUP           0x0D\n#define USB_PID_IN              0x09\n#define USB_PID_OUT             0x01\n#define USB_PID_ACK             0x02\n#define USB_PID_NAK             0x0A\n#define USB_PID_STALL           0x0E\n#define USB_PID_DATA0           0x03\n#define USB_PID_DATA1           0x0B\n#define USB_PID_PRE             0x0C\n#endif\n\n/* USB standard device request code */\n#ifndef USB_GET_DESCRIPTOR\n#define USB_GET_STATUS          0x00\n#define USB_CLEAR_FEATURE       0x01\n#define USB_SET_FEATURE         0x03\n#define USB_SET_ADDRESS         0x05\n#define USB_GET_DESCRIPTOR      0x06\n#define USB_SET_DESCRIPTOR      0x07\n#define USB_GET_CONFIGURATION   0x08\n#define USB_SET_CONFIGURATION   0x09\n#define USB_GET_INTERFACE       0x0A\n#define USB_SET_INTERFACE       0x0B\n#define USB_SYNCH_FRAME         0x0C\n#endif\n\n/* USB hub class request code */\n#ifndef HUB_GET_DESCRIPTOR\n#define HUB_GET_STATUS          0x00\n#define HUB_CLEAR_FEATURE       0x01\n#define HUB_GET_STATE           0x02\n#define HUB_SET_FEATURE         0x03\n#define HUB_GET_DESCRIPTOR      0x06\n#define HUB_SET_DESCRIPTOR      0x07\n#endif\n\n/* USB HID class request code */\n#ifndef HID_GET_REPORT\n#define HID_GET_REPORT          0x01\n#define HID_GET_IDLE            0x02\n#define HID_GET_PROTOCOL        0x03\n#define HID_SET_REPORT          0x09\n#define HID_SET_IDLE            0x0A\n#define HID_SET_PROTOCOL        0x0B\n#endif\n\n/* Bit define for USB request type */\n#ifndef USB_REQ_TYP_MASK\n#define USB_REQ_TYP_IN          0x80            /* control IN, device to host */\n#define USB_REQ_TYP_OUT         0x00            /* control OUT, host to device */\n#define USB_REQ_TYP_READ        0x80            /* control read, device to host */\n#define USB_REQ_TYP_WRITE       0x00            /* control write, host to device */\n#define USB_REQ_TYP_MASK        0x60            /* bit mask of request type */\n#define USB_REQ_TYP_STANDARD    0x00\n#define USB_REQ_TYP_CLASS       0x20\n#define USB_REQ_TYP_VENDOR      0x40\n#define USB_REQ_TYP_RESERVED    0x60\n#define USB_REQ_RECIP_MASK      0x1F            /* bit mask of request recipient */\n#define USB_REQ_RECIP_DEVICE    0x00\n#define USB_REQ_RECIP_INTERF    0x01\n#define USB_REQ_RECIP_ENDP      0x02\n#define USB_REQ_RECIP_OTHER     0x03\n#endif\n\n/* USB request type for hub class request */\n#ifndef HUB_GET_HUB_DESCRIPTOR\n#define HUB_CLEAR_HUB_FEATURE   0x20\n#define HUB_CLEAR_PORT_FEATURE  0x23\n#define HUB_GET_BUS_STATE       0xA3\n#define HUB_GET_HUB_DESCRIPTOR  0xA0\n#define HUB_GET_HUB_STATUS      0xA0\n#define HUB_GET_PORT_STATUS     0xA3\n#define HUB_SET_HUB_DESCRIPTOR  0x20\n#define HUB_SET_HUB_FEATURE     0x20\n#define HUB_SET_PORT_FEATURE    0x23\n#endif\n\n/* Hub class feature selectors */\n#ifndef HUB_PORT_RESET\n#define HUB_C_HUB_LOCAL_POWER   0\n#define HUB_C_HUB_OVER_CURRENT  1\n#define HUB_PORT_CONNECTION     0\n#define HUB_PORT_ENABLE         1\n#define HUB_PORT_SUSPEND        2\n#define HUB_PORT_OVER_CURRENT   3\n#define HUB_PORT_RESET          4\n#define HUB_PORT_POWER          8\n#define HUB_PORT_LOW_SPEED      9\n#define HUB_C_PORT_CONNECTION   16\n#define HUB_C_PORT_ENABLE       17\n#define HUB_C_PORT_SUSPEND      18\n#define HUB_C_PORT_OVER_CURRENT 19\n#define HUB_C_PORT_RESET        20\n#endif\n\n/* USB descriptor type */\n#ifndef USB_DESCR_TYP_DEVICE\n#define USB_DESCR_TYP_DEVICE    0x01\n#define USB_DESCR_TYP_CONFIG    0x02\n#define USB_DESCR_TYP_STRING    0x03\n#define USB_DESCR_TYP_INTERF    0x04\n#define USB_DESCR_TYP_ENDP      0x05\n#define USB_DESCR_TYP_QUALIF    0x06\n#define USB_DESCR_TYP_SPEED     0x07\n#define USB_DESCR_TYP_OTG       0x09\n#define USB_DESCR_TYP_HID       0x21\n#define USB_DESCR_TYP_REPORT    0x22\n#define USB_DESCR_TYP_PHYSIC    0x23\n#define USB_DESCR_TYP_CS_INTF   0x24\n#define USB_DESCR_TYP_CS_ENDP   0x25\n#define USB_DESCR_TYP_HUB       0x29\n#endif\n\n/* USB device class */\n#ifndef USB_DEV_CLASS_HUB\n#define USB_DEV_CLASS_RESERVED  0x00\n#define USB_DEV_CLASS_AUDIO     0x01\n#define USB_DEV_CLASS_COMMUNIC  0x02\n#define USB_DEV_CLASS_HID       0x03\n#define USB_DEV_CLASS_MONITOR   0x04\n#define USB_DEV_CLASS_PHYSIC_IF 0x05\n#define USB_DEV_CLASS_POWER     0x06\n#define USB_DEV_CLASS_PRINTER   0x07\n#define USB_DEV_CLASS_STORAGE   0x08\n#define USB_DEV_CLASS_HUB       0x09\n#define USB_DEV_CLASS_VEN_SPEC  0xFF\n#endif\n\n/* USB endpoint type and attributes */\n#ifndef USB_ENDP_TYPE_MASK\n#define USB_ENDP_DIR_MASK       0x80\n#define USB_ENDP_ADDR_MASK      0x0F\n#define USB_ENDP_TYPE_MASK      0x03\n#define USB_ENDP_TYPE_CTRL      0x00\n#define USB_ENDP_TYPE_ISOCH     0x01\n#define USB_ENDP_TYPE_BULK      0x02\n#define USB_ENDP_TYPE_INTER     0x03\n#endif\n\n#ifndef USB_DEVICE_ADDR\n#define	USB_DEVICE_ADDR			0x02	/* 默认的USB设备地址 */\n#endif\n#ifndef DEFAULT_ENDP0_SIZE\n#define DEFAULT_ENDP0_SIZE      8       /* default maximum packet size for endpoint 0 */\n#endif\n#ifndef MAX_PACKET_SIZE\n#define MAX_PACKET_SIZE         64      /* maximum packet size */\n#endif\n#ifndef USB_BO_CBW_SIZE\n#define USB_BO_CBW_SIZE			0x1F	/* 命令块CBW的总长度 */\n#define USB_BO_CSW_SIZE			0x0D	/* 命令状态块CSW的总长度 */\n#endif\n#ifndef USB_BO_CBW_SIG0\n#define USB_BO_CBW_SIG0         0x55    /* 命令块CBW识别标志'USBC' */\n#define USB_BO_CBW_SIG1         0x53\n#define USB_BO_CBW_SIG2         0x42\n#define USB_BO_CBW_SIG3         0x43\n#define USB_BO_CSW_SIG0         0x55    /* 命令状态块CSW识别标志'USBS' */\n#define USB_BO_CSW_SIG1         0x53\n#define USB_BO_CSW_SIG2         0x42\n#define USB_BO_CSW_SIG3         0x53\n#endif\n\ntypedef struct _USB_SETUP_REQ {\n    UINT8 bRequestType;\n    UINT8 bRequest;\n    UINT8 wValueL;\n    UINT8 wValueH;\n    UINT8 wIndexL;\n    UINT8 wIndexH;\n    UINT8 wLengthL;\n    UINT8 wLengthH;\n} USB_SETUP_REQ, *PUSB_SETUP_REQ;\n\ntypedef USB_SETUP_REQ xdata *PXUSB_SETUP_REQ;\n\ntypedef struct _USB_DEVICE_DESCR {\n    UINT8 bLength;\n    UINT8 bDescriptorType;\n    UINT8 bcdUSBL;\n    UINT8 bcdUSBH;\n    UINT8 bDeviceClass;\n    UINT8 bDeviceSubClass;\n    UINT8 bDeviceProtocol;\n    UINT8 bMaxPacketSize0;\n    UINT8 idVendorL;\n    UINT8 idVendorH;\n    UINT8 idProductL;\n    UINT8 idProductH;\n    UINT8 bcdDeviceL;\n    UINT8 bcdDeviceH;\n    UINT8 iManufacturer;\n    UINT8 iProduct;\n    UINT8 iSerialNumber;\n    UINT8 bNumConfigurations;\n} USB_DEV_DESCR, *PUSB_DEV_DESCR;\n\ntypedef USB_DEV_DESCR xdata *PXUSB_DEV_DESCR;\n\ntypedef struct _USB_CONFIG_DESCR {\n    UINT8 bLength;\n    UINT8 bDescriptorType;\n    UINT8 wTotalLengthL;\n    UINT8 wTotalLengthH;\n    UINT8 bNumInterfaces;\n    UINT8 bConfigurationValue;\n    UINT8 iConfiguration;\n    UINT8 bmAttributes;\n    UINT8 MaxPower;\n} USB_CFG_DESCR, *PUSB_CFG_DESCR;\n\ntypedef USB_CFG_DESCR xdata *PXUSB_CFG_DESCR;\n\ntypedef struct _USB_INTERF_DESCR {\n    UINT8 bLength;\n    UINT8 bDescriptorType;\n    UINT8 bInterfaceNumber;\n    UINT8 bAlternateSetting;\n    UINT8 bNumEndpoints;\n    UINT8 bInterfaceClass;\n    UINT8 bInterfaceSubClass;\n    UINT8 bInterfaceProtocol;\n    UINT8 iInterface;\n} USB_ITF_DESCR, *PUSB_ITF_DESCR;\n\ntypedef USB_ITF_DESCR xdata *PXUSB_ITF_DESCR;\n\ntypedef struct _USB_ENDPOINT_DESCR {\n    UINT8 bLength;\n    UINT8 bDescriptorType;\n    UINT8 bEndpointAddress;\n    UINT8 bmAttributes;\n    UINT8 wMaxPacketSizeL;\n    UINT8 wMaxPacketSizeH;\n    UINT8 bInterval;\n} USB_ENDP_DESCR, *PUSB_ENDP_DESCR;\n\ntypedef USB_ENDP_DESCR xdata *PXUSB_ENDP_DESCR;\n\ntypedef struct _USB_CONFIG_DESCR_LONG {\n    USB_CFG_DESCR   cfg_descr;\n    USB_ITF_DESCR   itf_descr;\n    USB_ENDP_DESCR  endp_descr[1];\n} USB_CFG_DESCR_LONG, *PUSB_CFG_DESCR_LONG;\n\ntypedef USB_CFG_DESCR_LONG xdata *PXUSB_CFG_DESCR_LONG;\n\ntypedef struct _USB_HUB_DESCR {\n    UINT8 bDescLength;\n    UINT8 bDescriptorType;\n    UINT8 bNbrPorts;\n    UINT8 wHubCharacteristicsL;\n    UINT8 wHubCharacteristicsH;\n    UINT8 bPwrOn2PwrGood;\n    UINT8 bHubContrCurrent;\n    UINT8 DeviceRemovable;\n    UINT8 PortPwrCtrlMask;\n} USB_HUB_DESCR, *PUSB_HUB_DESCR;\n\ntypedef USB_HUB_DESCR xdata *PXUSB_HUB_DESCR;\n\ntypedef struct _USB_HID_DESCR {\n    UINT8 bLength;\n    UINT8 bDescriptorType;\n    UINT8 bcdHIDL;\n    UINT8 bcdHIDH;\n    UINT8 bCountryCode;\n    UINT8 bNumDescriptors;\n    UINT8 bDescriptorTypeX;\n    UINT8 wDescriptorLengthL;\n    UINT8 wDescriptorLengthH;\n} USB_HID_DESCR, *PUSB_HID_DESCR;\n\ntypedef USB_HID_DESCR xdata *PXUSB_HID_DESCR;\n\ntypedef struct _UDISK_BOC_CBW {         /* command of BulkOnly USB-FlashDisk */\n    UINT8 mCBW_Sig0;\n    UINT8 mCBW_Sig1;\n    UINT8 mCBW_Sig2;\n    UINT8 mCBW_Sig3;\n    UINT8 mCBW_Tag0;\n    UINT8 mCBW_Tag1;\n    UINT8 mCBW_Tag2;\n    UINT8 mCBW_Tag3;\n    UINT8 mCBW_DataLen0;\n    UINT8 mCBW_DataLen1;\n    UINT8 mCBW_DataLen2;\n    UINT8 mCBW_DataLen3;                /* uppest byte of data length, always is 0 */\n    UINT8 mCBW_Flag;                    /* transfer direction and etc. */\n    UINT8 mCBW_LUN;\n    UINT8 mCBW_CB_Len;                  /* length of command block */\n    UINT8 mCBW_CB_Buf[16];              /* command block buffer */\n} UDISK_BOC_CBW, *PUDISK_BOC_CBW;\n\ntypedef UDISK_BOC_CBW xdata *PXUDISK_BOC_CBW;\n\ntypedef struct _UDISK_BOC_CSW {         /* status of BulkOnly USB-FlashDisk */\n    UINT8 mCSW_Sig0;\n    UINT8 mCSW_Sig1;\n    UINT8 mCSW_Sig2;\n    UINT8 mCSW_Sig3;\n    UINT8 mCSW_Tag0;\n    UINT8 mCSW_Tag1;\n    UINT8 mCSW_Tag2;\n    UINT8 mCSW_Tag3;\n    UINT8 mCSW_Residue0;                /* return: remainder bytes */\n    UINT8 mCSW_Residue1;\n    UINT8 mCSW_Residue2;\n    UINT8 mCSW_Residue3;                /* uppest byte of remainder length, always is 0 */\n    UINT8 mCSW_Status;                  /* return: result status */\n} UDISK_BOC_CSW, *PUDISK_BOC_CSW;\n\ntypedef UDISK_BOC_CSW xdata *PXUDISK_BOC_CSW;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // __USB_DEF__\n"
                editor_header.setValue(ch549_h)
                editor_header.setOption("readOnly", true)
            }
            else if (selected == "Others") {
                editor_header.setValue("// 请将头文件的代码复制至此代码框内")
                editor_header.setOption("readOnly", false)
            }
        }

        function parse_keilc51_reg_addrs(code) {
            var reg_addrs = {}
            var reg_bits = {}
            var code_in_list = code.split('\n')
            for (var i = 0; i < code_in_list.length; i++) {
                var line = code_in_list[i]
                var extraction = null;
                var equalsign_index = line.indexOf("=")
                var comment_index = line.indexOf("//")
                if (equalsign_index >= 0) {
                    if ((comment_index < 0) || (equalsign_index < comment_index)) {
                        var code = line.substring(line.indexOf('s'), line.indexOf(';'))
                        extraction = code.split(/\s+/)
                        extraction.push(line.substring(line.indexOf(';') + 1))

                        if (extraction[0] == "sfr" || extraction[0] == "sfr16") {
                            reg_addrs[extraction[1]] = extraction[3]
                        }
                        else if (extraction[0] == "sbit") {
                            regname = extraction[3].split('^')[0]
                            regaddr = reg_addrs[regname]
                            regbit = extraction[3].split('^')[1]
                            reg_bits[extraction[1]] = regname + ',' + regaddr + ',' + regbit
                        }
                    }
                }
            }
            return [reg_addrs, reg_bits]
        }

        function convert_keilc51_to_sdcc(code_keilc51, code_header) {
            // Ref: https://gitee.com/wch51tutorial-developer/vm-wch-51-tutorial-keil2sdcc51

            // FIXME: 本函数的不足：/* 多行注释中被匹配到的内容也会被转换 */

            // 从头文件里读取各个寄存器的地址
            try {
                var parsed = parse_keilc51_reg_addrs(code_header)
                var reg_addrs = parsed[0]
                var reg_bits = parsed[1]
            }
            catch (err) {
                console.log("因头文件格式问题转换失败，原因为：")
                console.log(err)
                return "转换失败，头文件格式不太正确！请使用格式正确的 Keil C51 版本的头文件。"
            }

            // 实际转换
            try {
                var convert_result = "// 转换后的代码如下\n//\n////////////////////////////////////////////////////////////////\n#include <compiler.h>    // 请在本网页下载此头文件(https://csy-tvgo.github.io/Keil-C51-C-to-SDCC-C-Converter)\n"
                var code_keilc51_in_list = code_keilc51.split('\n')
                for (var i = 0; i < code_keilc51_in_list.length; i++) {
                    var line = code_keilc51_in_list[i]
                    var comment_index = line.indexOf("//")

                    // 替换关键字
                    var keywords = ["bit", "data", "idata", "xdata", "pdata", "code"]
                    for (var j = 0; j < keywords.length; j++) {
                        var keyword_index = line.indexOf(keywords[j])
                        if (keyword_index >= 0) {
                            if ((comment_index < 0) || (keyword_index < comment_index)) {
                                if ((keyword_index == 0) &&
                                    ((line[keywords[j].length] == ' ') || (line[keywords[j].length] == '\t'))) {
                                    line = "__" + line
                                }
                                else if ((keyword_index > 0) &&
                                    (((line[keyword_index - 1] == ' ') && (line[keyword_index + keywords[j].length] == ' ')) ||
                                        ((line[keyword_index - 1] == '\t') && (line[keyword_index + keywords[j].length] == ' ')) ||
                                        ((line[keyword_index - 1] == ' ') && (line[keyword_index + keywords[j].length] == '\t')))) {
                                    line = line.substring(0, keyword_index) + "__" + line.substring(keyword_index)
                                }
                            }
                        }
                    }

                    // 转换 sfr/sfr16/sbit 的格式
                    var equalsign_index = line.indexOf("=")
                    var comment_index = line.indexOf("//")
                    if (equalsign_index >= 0) {
                        if ((comment_index < 0) || (equalsign_index < comment_index)) {
                            var s_index = line.indexOf('s')
                            var semicolon_index = line.indexOf(';')
                            var code = line.substring(s_index, semicolon_index)
                            var extraction = code.split(/\s+/)
                            var comment = line.substring(line.indexOf(';') + 1)
                            if ((extraction[0] == "sfr") || (extraction[0] == "sfr16")) {
                                reg_addrs[extraction[1]] = extraction[3]
                                line = line.replace(extraction[0], extraction[0].toUpperCase() + '(')
                                line = line.replace('=', ',')
                                line = line.replace(extraction[3], extraction[3] + ')')
                                if (extraction[3] in reg_addrs) {
                                    line = line.substring(0, line.indexOf(')')) + "/*" +
                                        extraction[3] + "*/" + line.substring(line.indexOf(')'))
                                    line = line.replace(extraction[3], reg_addrs[extraction[3]])
                                }
                            }
                            else if (extraction[0] == "sbit") {
                                regname = extraction[3].split('^')[0]
                                regaddr = reg_addrs[regname]
                                regbit = extraction[3].split('^')[1]
                                reg_bits[extraction[1]] = regname + ',' + regaddr + ',' + regbit

                                line = line.replace(extraction[0], extraction[0].toUpperCase() + '(')
                                line = line.replace('=', ',')
                                line = line.replace('^', ', ')
                                line = line.replace(";", ");")

                                if (regname in reg_addrs) {
                                    line = line.substring(0, line.indexOf(regname + ',') + regname.length) + "/*" +
                                        regname + "*/" + line.substring(line.indexOf(regname + ',') + regname.length)
                                    line = line.replace(regname + '/', regaddr + '/')
                                }
                            }
                        }
                    }

                    convert_result += line + '\n'
                }
            }
            catch (err) {
                console.log("因 Keil C51 代码格式问题转换失败，原因为：")
                console.log(err)
                return "转换失败， Keil C51 代码格式不太正确！请使用格式正确的代码。"
            }

            return convert_result
        }

        function execute_convert() {
            var code_keilc51 = editor_keilc51.getValue()
            var code_header = editor_header.getValue()

            var notice = "//\n// 已读取，请在最右侧栏查看转换结果\n//\n////////////////////////////////////////////////////////////////\n"
            if (code_keilc51.indexOf(notice) != 0) {
                editor_keilc51.setValue(notice + code_keilc51)
            }
            else {
                code_keilc51 = code_keilc51.replace(notice, "")
            }

            var code_sdcc = convert_keilc51_to_sdcc(code_keilc51, code_header)
            editor_sdcc.setValue(code_sdcc)
        }

        function copyResult() {
            // Ref: https://www.30secondsofcode.org/articles/s/copy-text-to-clipboard-with-javascript
            const el = document.createElement('textarea')
            el.value = editor_sdcc.getValue();
            el.setAttribute('readonly', '')
            el.style.position = 'absolute'
            el.style.left = '-9999px'
            document.body.appendChild(el)
            el.select()
            document.execCommand('copy')
            document.body.removeChild(el)
            alert("\n你点击了复制按钮！\n\n（有的浏览器能复制成功，有的不能）")
        }

    </script>

</body>

</html>